[{"title":"CoreFoundation源码解读之CFArray","date":"2017-02-07T13:10:17.000Z","path":"2017/02/07/CoreFoundation源码解读之CFArray/","text":"前言算是CoreFoundation源码解析的第一篇吧，之后有机会希望能做更多的源码解析，其实做这块的原因很简单，关于这块的解析还是蛮少，而作为一名iOS的开发工程师，没有比学习官方源码的方式更简单粗暴，可以从中吸取到很多内部的代码风格，与代码的技巧。 以下内容我会分为几个部分： 简单介绍下从网上查到的资料 分析源码，介绍从源码中获取到的有用知识 CFArray的发展最开始（CF-635.15以前） CFArray是由两种数据结构实现的 Double-ended queue ：数组长度较小时使用(&lt;262040) ，直接使用CFArrayDeque实现，此时在头尾插入删除性能高，但是在中间插入删除时，就需要 memmove 来挪动内存了，性能就会降下来 balanced tree：数组长度较大时使用（&gt;=262040），改成使用CFStorage实现，利用balanced tree 实现了大数量的数值的存储和编辑，并且在插入和删除时有很好的性能 备注：准确点来说是三种，还有一种就是普通的开辟一段连续空间存储不可变数组CFArrayRef，但这里主要讨论的是CFMutableArrayRef，所以把它忽略掉 之后（CF-635.15 ~ CF-1153.18） 去掉了CFStorage部分，在LONG_MAX以内都是用deque 最新(CF-1153.18以后) 据说改成了circular buffer，但最新的代码一直都是coming soon! 对比NSArray这里值的一提的是虽然CFArray是开源，但NSArray是闭源的。但尽管如此，还是有人逆向去探索NSArray的实现，大家有兴趣的话可以看下国外的大牛是怎么探索的Exposing NSMutableArray，我这里就不班门弄斧了，这里直接给出的结论是： NSMutableArray实际上也是用circular buffer（环形缓冲器）来实现的 而这篇文章的的最后也指出：现在开源的最新版本(CF-635.15 ~ CF-1153.18)的工作原理其实和环形缓冲器相似，但本质上并不是环形缓冲器，那我们就来看下当前开源版本是怎么相似法 Basically, CFArray moves the memory around to accommodate the changes in the most efficient fashion, similarly to how __NSArrayM does its job. However, the CFArray does not use a circular buffer! Instead it has a larger buffer padded with zeros from both ends which makes enumeration and fetching the correct object much easier. Adding elements at either end simply eats up the remaining padding. CFArray源码解读首先上官网把源码下载下来：CF-1153.18 ，找到CFArray.c/.h，这就是我们要阅读的源码 开可以看到代码量很多而且比较乱，我这里按照功能整理了一下： 以下是我分类的目录： 最后我会把我整理过的代码上传上去上去，有需要的可以自行下载 数组的声明——大致了解数组的结构先来看下数组的结构体声明： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 所有的这些枚举值会写进一个32位的整数里，通过二进制里bits位来标识 *///分别代表两种类型的数组__kCFArrayImmutable为CFArray//分别代表两种类型的数组__kCFArrayImmutable为CFMutableArray/* Flag bits */enum &#123; /* Bits 0-1 */ __kCFArrayImmutable = 0, __kCFArrayDeque = 2,&#125;;enum &#123; /* Bits 2-3 */ __kCFArrayHasNullCallBacks = 0, __kCFArrayHasCFTypeCallBacks = 1, __kCFArrayHasCustomCallBacks = 3 /* callbacks are at end of header */&#125;;/* Bits 4 &amp; 5 are reserved for GC use. Bit 4, if set, indicates that the array is weak. Bit 5 marks whether finalization has occured and, thus, whether to continue to do special retain/release processing of elements. */#pragma mark structstruct __CFArray &#123; /** CFRuntimeBase在CFRuntime.h中定义 typedef struct __CFRuntimeBase &#123; uintptr_t _cfisa; uint8_t _cfinfo[4]; #if __LP64__ uint32_t _rc; #endif &#125; CFRuntimeBase; */ CFRuntimeBase _base; //这个是用来存数组元素数量的 CFIndex _count; /* number of objects */ CFIndex _mutations; //初始化为1 int32_t _mutInProgress; //初始化为0 //这个是用来存数组元素的,__kCFArrayDeque类型下，_store就是__CFArrayDeque __strong void *_store; //初始为空，Mutable加元素的时候才会创建 /* can be NULL when MutableDeque */&#125;;struct __CFArrayDeque &#123; uintptr_t _leftIdx; uintptr_t _capacity; /* struct __CFArrayBucket buckets follow here */&#125;;struct __CFArrayBucket &#123; const void *_item;&#125;; 首先数组分类两类： __kCFArrayImmutable不可变数组 __kCFArrayDeque可变数组 但实际中两者都使用的是同一个结构体：__CFArray（只是类型不同，以及存储方式不一样，后面会讲到） __CFArray结构体： CFRuntimeBase _base：其实不止这两个数组包含这个结构体，应该说所有CF类型的结构体都会包含这个结构体，主要作用是方便runtime统一调度管理。在本次介绍中主要涉及到的是__cfinfo的CF_INFO_BITS位（第0位）它主要存储了数组的所有状态 CFIndex _count：记录数组数量 CFIndex _mutations： 记录数组的操作次数，每次操作数组后加1，初始创建时就为1 int32_t _mutInProgress：用于检测此时是否正在操作数组，防止多个线程同一时间操作同一个数组 __strong void *_store：这是两种类型数组的一个其中一个比较大的区别： 不可变数组：一般为NULL 可变数组：在数组元素为空的时候也为NULL，有数据的时候_store指向__CFArrayDeque结构体 __CFArrayBucket结构体： 这个结构体里面就只有一个成员const void *_item const void item：也是一个指针，**实际上CFArray中的每个元素都对应一个\\_CFArrayBucket,而__CFArrayBucket里的_item指针唯一指向对应的这个元素* 关于__CFArrayDeque的结构体，我会放到后面跟着源码一起来介绍。 数组的创建——分析不可变数组在内存中的存储方式123456789101112#define DEFINE_CREATION_METHODS 1#if DEFINE_CREATION_METHODS///对外Array创建方法CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks) &#123; return __CFArrayCreate0(allocator, values, numValues, callBacks);&#125;///对外MutableArray创建方法CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks) &#123; return __CFArrayCreateMutable0(allocator, capacity, callBacks);&#125;#endif 数组对外的创建主要有两个 CFArrayCreate 调用__CFArrayCreate0方法创建 CFArrayCreateMutable调用__CFArrayCreateMutable0方法创建 再来看下这两个内部方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** 创建一个CFArrayRef不可变数组 * @param allocator 是使用已有的空间还是开辟新的空间来创建数组. 传 NULL 或者 kCFAllocatorDefault 使用默认的allocator * @param values c语言数组指针 * @param numValues 数组个数 * @param callBacks 一个 CFArrayCallBacks的结构指针 *///CFArrayRef 内部创建方法，调用__CFArrayInitCF_PRIVATE CFArrayRef __CFArrayCreate0(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks) &#123; CFArrayRef result; const CFArrayCallBacks *cb; struct __CFArrayBucket *buckets; CFAllocatorRef bucketsAllocator; void* bucketsBase; CFIndex idx; CFAssert2(0 &lt;= numValues, __kCFLogAssertion, &quot;%s(): numValues (%d) cannot be less than zero&quot;, __PRETTY_FUNCTION__, numValues); //__CFArrayInit初始化 result = __CFArrayInit(allocator, __kCFArrayImmutable, numValues, callBacks); //获取callback cb = __CFArrayGetCallBacks(result); //每个数组元素都用一个bucket装着，通过结构体指针来索引，结构体指针顺序存储，通过指针+1来获取对应bucket指针，从而利用item索引对应的元素 buckets = __CFArrayGetBucketsPtr(result); bucketsAllocator = isStrongMemory(result) ? allocator : kCFAllocatorNull; bucketsBase = CF_IS_COLLECTABLE_ALLOCATOR(bucketsAllocator) ? (void *)auto_zone_base_pointer(objc_collectableZone(), buckets) : NULL; if (NULL != cb-&gt;retain) &#123; for (idx = 0; idx &lt; numValues; idx++) &#123; /** 在CFInternal.h里定义 CF_INLINE void __CFAssignWithWriteBarrier(void **location, void *value) &#123; if (kCFUseCollectableAllocator) &#123; objc_assign_strongCast((id)value, (id *)location); &#125; else &#123; *location = value; &#125; &#125; */ //__CFAssignWithWriteBarrier((void **)&amp;buckets-&gt;_item, (void *)(cb-&gt;retain)(allocator, *values)); __CFAssignWithWriteBarrier((void **)&amp;buckets-&gt;_item, (void *)INVOKE_CALLBACK2(cb-&gt;retain, allocator, *values)); values++; buckets++; &#125; &#125; else &#123; for (idx = 0; idx &lt; numValues; idx++) &#123; __CFAssignWithWriteBarrier((void **)&amp;buckets-&gt;_item, (void *)*values); values++; buckets++; &#125; &#125; //设置__CFArray结构体的数组大小 __CFArraySetCount(result, numValues); return result;&#125;/** 创建一个CFMutableArrayRef可变数组 *///CFMutableArrayRef 内部创建方法（直接调用__CFArrayInit初始化即可）CF_PRIVATE CFMutableArrayRef __CFArrayCreateMutable0(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks) &#123; //断言 CFAssert2(0 &lt;= capacity, __kCFLogAssertion, &quot;%s(): capacity (%d) cannot be less than zero&quot;, __PRETTY_FUNCTION__, capacity); CFAssert2(capacity &lt;= LONG_MAX / sizeof(void *), __kCFLogAssertion, &quot;%s(): capacity (%d) is too large for this architecture&quot;, __PRETTY_FUNCTION__, capacity); //__CFArrayInit初始化 return (CFMutableArrayRef)__CFArrayInit(allocator, __kCFArrayDeque, capacity, callBacks);&#125; 从__CFArrayCreate0里对buckets的操作其实就可以推断出不可变的数组数据结构了，为了确保推断无误，我们继续看下，这两个方法都会调用基础方法__CFArrayInit 以下是__CFArrayInit的源码: (注释里写了一些使用到的，在别的文件中定义的相关宏，以供参考) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** 初始化一个CFArrayRef数组 * @param allocator 是使用已有的空间还是新的空间来创建数组. 传 NULL 或者 kCFAllocatorDefault 使用默认的allocator * @param flags 数组类型：__kCFArrayImmutable 不可变数组/__kCFArrayDeque 可变数组 * @param capacity 数组大小 * @param callBacks 一个 CFArrayCallBacks的结构指针 *////#if (TARGET_OS_MAC &amp;&amp; !(TARGET_OS_EMBEDDED || TARGET_OS_IPHONE))///#define CF_IS_COLLECTABLE_ALLOCATOR(allocator) (kCFUseCollectableAllocator &amp;&amp; (NULL == (allocator) || kCFAllocatorSystemDefault == (allocator) || 0))///#else 0///#endif///#define INVOKE_CALLBACK2(P, A, B) (P)(A, B)///#define __CFBitfieldGetValue(V, N1, N2) (((V) &amp; __CFBitfieldMask(N1, N2)) &gt;&gt; (N2))///#define __CFBitfieldMask(N1, N2) ((((UInt32)~0UL) &lt;&lt; (31UL - (N1) + (N2))) &gt;&gt; (31UL - N1))///#define __CFBitfieldSetValue(V, N1, N2, X) ((V) = ((V) &amp; ~__CFBitfieldMask(N1, N2)) | (((X) &lt;&lt; (N2)) &amp; __CFBitfieldMask(N1, N2)))static CFArrayRef __CFArrayInit(CFAllocatorRef allocator, UInt32 flags, CFIndex capacity, const CFArrayCallBacks *callBacks) &#123; struct __CFArray *memory; UInt32 size; //对于Uint32位的flags，取出2~31位的数设置成0 __CFBitfieldSetValue(flags, 31, 2, 0); if (CF_IS_COLLECTABLE_ALLOCATOR(allocator))//ALLOCATOR = NULL 时为NO &#123; if (!callBacks || (callBacks-&gt;retain == NULL &amp;&amp; callBacks-&gt;release == NULL)) &#123; __CFBitfieldSetValue(flags, 4, 4, 1); // setWeak &#125; &#125; //利用2-3位来标识callback类型 if (__CFArrayCallBacksMatchNull(callBacks)) &#123; __CFBitfieldSetValue(flags, 3, 2, __kCFArrayHasNullCallBacks); &#125; else if (__CFArrayCallBacksMatchCFType(callBacks)) &#123; __CFBitfieldSetValue(flags, 3, 2, __kCFArrayHasCFTypeCallBacks); &#125; else &#123; __CFBitfieldSetValue(flags, 3, 2, __kCFArrayHasCustomCallBacks); &#125; //size =__CFArray结构体大小+ callBack结构体大小（如果有自定义的话）- CFRuntimeBase结构体大小 size = __CFArrayGetSizeOfType(flags) - sizeof(CFRuntimeBase); //利用0-1位来标识数组类型是__kCFArrayImmutable还是__kCFArrayDeque //size =__CFArray结构体大小+ callBack结构体大小（如果有自定义的话）- CFRuntimeBase结构体大小 + 个数 * __CFArrayBucket结构体大小 switch (__CFBitfieldGetValue(flags, 1, 0)) &#123; case __kCFArrayImmutable: size += capacity * sizeof(struct __CFArrayBucket); break; case __kCFArrayDeque: break; &#125; //Runtime创建空间，注意_CFRuntimeCreateInstance需要的参数是extraBytes，需要除去CFRuntimeBase大小。 就是上面的size，事实上可以通过查看_CFRuntimeCreateInstance的源码知道CFRuntimeBase是内部创建的，外部并不需要管 memory = (struct __CFArray*)_CFRuntimeCreateInstance(allocator, CFArrayGetTypeID(), size, NULL); if (NULL == memory) &#123; return NULL; &#125; //初始化CFRuntimeBase结构体参数 //把flags信息存进结构体中 __CFBitfieldSetValue(memory-&gt;_base._cfinfo[CF_INFO_BITS], 6, 0, flags); //初始化结构体的数组大小 __CFArraySetCount((CFArrayRef)memory, 0); //利用0-1位来标识数组类型是__kCFArrayImmutable还是__kCFArrayDeque switch (__CFBitfieldGetValue(flags, 1, 0)) &#123; case __kCFArrayImmutable: if (isWeakMemory(memory)) &#123; // if weak, don&apos;t scan auto_zone_set_unscanned(objc_collectableZone(), memory); &#125; if (__CFOASafe) __CFSetLastAllocationEventName(memory, &quot;CFArray (immutable)&quot;); break; case __kCFArrayDeque: if (__CFOASafe) __CFSetLastAllocationEventName(memory, &quot;CFArray (mutable-variable)&quot;); ((struct __CFArray *)memory)-&gt;_mutations = 1; ((struct __CFArray *)memory)-&gt;_mutInProgress = 0; ((struct __CFArray*)memory)-&gt;_store = NULL; break; &#125; //设置callback if (__kCFArrayHasCustomCallBacks == __CFBitfieldGetValue(flags, 3, 2)) &#123; CFArrayCallBacks *cb = (CFArrayCallBacks *)__CFArrayGetCallBacks((CFArrayRef)memory); *cb = *callBacks; FAULT_CALLBACK((void **)&amp;(cb-&gt;retain)); FAULT_CALLBACK((void **)&amp;(cb-&gt;release)); FAULT_CALLBACK((void **)&amp;(cb-&gt;copyDescription)); FAULT_CALLBACK((void **)&amp;(cb-&gt;equal)); &#125; return (CFArrayRef)memory;&#125; __CFArrayInit最主要职责是开辟对应的空间，然后设置数组的CallBacks、状态位，把状态位写进_base._cfinfo[CF_INFO_BITS]里。 这里总结出个有用的技巧： 当一个对象有很多状态需要标识的时候，最好的方法不是设置多个布尔属性、枚举属性，而是直接使用一个32（或者16）位的整形数来存储所有状态，将这个整形数转换成二进制，利用不同位数代表的不同状态。 小结——不可变数组在内存的存储方式从以上的代码就可以大致分析出不可变数组的数据结构，如下： 由于可变数组在整个创建过程中并没有对数据进行操作，接下来，我们需要进一步阅读可变数组对数据的增删改查来进一步了解可变数组的存储方式。 数组的增删改查——分析可变数组在内存中的存储方式增：为可变数组添加元素123456789101112131415161718192021222324252627282930//添加#pragma mark add//在数组idx位置中插入一个元素（调用_CFArrayReplaceValues）void CFArrayInsertValueAtIndex(CFMutableArrayRef array, CFIndex idx, const void *value) &#123; CF_OBJC_FUNCDISPATCHV(CFArrayGetTypeID(), void, (NSMutableArray *)array, insertObject:(id)value atIndex:(NSUInteger)idx); __CFGenericValidateType(array, CFArrayGetTypeID()); CFAssert1(__CFArrayGetType(array) != __kCFArrayImmutable, __kCFLogAssertion, &quot;%s(): array is immutable&quot;, __PRETTY_FUNCTION__); CFAssert2(0 &lt;= idx &amp;&amp; idx &lt;= __CFArrayGetCount(array), __kCFLogAssertion, &quot;%s(): index (%d) out of bounds&quot;, __PRETTY_FUNCTION__, idx); CHECK_FOR_MUTATION(array); _CFArrayReplaceValues(array, CFRangeMake(idx, 0), &amp;value, 1);&#125;//在数组的最后插入一个元素（调用_CFArrayReplaceValues）void CFArrayAppendValue(CFMutableArrayRef array, const void *value) &#123; CF_OBJC_FUNCDISPATCHV(CFArrayGetTypeID(), void, (NSMutableArray *)array, addObject:(id)value); __CFGenericValidateType(array, CFArrayGetTypeID()); CFAssert1(__CFArrayGetType(array) != __kCFArrayImmutable, __kCFLogAssertion, &quot;%s(): array is immutable&quot;, __PRETTY_FUNCTION__); CHECK_FOR_MUTATION(array); _CFArrayReplaceValues(array, CFRangeMake(__CFArrayGetCount(array), 0), &amp;value, 1);&#125;//在数组的最后插入一个数组（调用CFArrayAppendValue）void CFArrayAppendArray(CFMutableArrayRef array, CFArrayRef otherArray, CFRange otherRange) &#123; __CFArrayValidateRange(otherArray, otherRange, __PRETTY_FUNCTION__); // implemented abstractly, careful! for (CFIndex idx = otherRange.location; idx &lt; otherRange.location + otherRange.length; idx++) &#123; CFArrayAppendValue(array, CFArrayGetValueAtIndex(otherArray, idx)); &#125;&#125; 删：为可变数组删除元素12345678910111213141516171819202122232425#pragma mark array delete//删除数组idx位置的元素（调用_CFArrayReplaceValues）void CFArrayRemoveValueAtIndex(CFMutableArrayRef array, CFIndex idx) &#123; CF_OBJC_FUNCDISPATCHV(CFArrayGetTypeID(), void, (NSMutableArray *)array, removeObjectAtIndex:(NSUInteger)idx); __CFGenericValidateType(array, CFArrayGetTypeID()); CFAssert1(__CFArrayGetType(array) != __kCFArrayImmutable, __kCFLogAssertion, &quot;%s(): array is immutable&quot;, __PRETTY_FUNCTION__); CFAssert2(0 &lt;= idx &amp;&amp; idx &lt; __CFArrayGetCount(array), __kCFLogAssertion, &quot;%s(): index (%d) out of bounds&quot;, __PRETTY_FUNCTION__, idx); CHECK_FOR_MUTATION(array); _CFArrayReplaceValues(array, CFRangeMake(idx, 1), NULL, 0);&#125;//删除数组中所有的元素（调用_CFArrayReplaceValues）void CFArrayRemoveAllValues(CFMutableArrayRef array) &#123; CF_OBJC_FUNCDISPATCHV(CFArrayGetTypeID(), void, (NSMutableArray *)array, removeAllObjects); __CFGenericValidateType(array, CFArrayGetTypeID()); CFAssert1(__CFArrayGetType(array) != __kCFArrayImmutable, __kCFLogAssertion, &quot;%s(): array is immutable&quot;, __PRETTY_FUNCTION__); CHECK_FOR_MUTATION(array); BEGIN_MUTATION(array); __CFArrayReleaseValues(array, CFRangeMake(0, __CFArrayGetCount(array)), true); __CFArraySetCount(array, 0); array-&gt;_mutations++; END_MUTATION(array);&#125; 改：为可变数组更改元素12345678910111213141516171819202122232425262728293031323334353637383940414243444546//修改#pragma mark modify//将第idx位置的元素修改成对应的值（调用_CFArrayReplaceValues）void CFArraySetValueAtIndex(CFMutableArrayRef array, CFIndex idx, const void *value) &#123; CF_OBJC_FUNCDISPATCHV(CFArrayGetTypeID(), void, (NSMutableArray *)array, setObject:(id)value atIndex:(NSUInteger)idx); __CFGenericValidateType(array, CFArrayGetTypeID()); CFAssert1(__CFArrayGetType(array) != __kCFArrayImmutable, __kCFLogAssertion, &quot;%s(): array is immutable&quot;, __PRETTY_FUNCTION__); CFAssert2(0 &lt;= idx &amp;&amp; idx &lt;= __CFArrayGetCount(array), __kCFLogAssertion, &quot;%s(): index (%d) out of bounds&quot;, __PRETTY_FUNCTION__, idx); CHECK_FOR_MUTATION(array); if (idx == __CFArrayGetCount(array)) &#123; _CFArrayReplaceValues(array, CFRangeMake(idx, 0), &amp;value, 1); &#125; else &#123; BEGIN_MUTATION(array); const void *old_value; const CFArrayCallBacks *cb = __CFArrayGetCallBacks(array); CFAllocatorRef allocator = __CFGetAllocator(array); struct __CFArrayBucket *bucket = __CFArrayGetBucketAtIndex(array, idx); if (NULL != cb-&gt;retain &amp;&amp; !hasBeenFinalized(array)) &#123; value = (void *)INVOKE_CALLBACK2(cb-&gt;retain, allocator, value); &#125; old_value = bucket-&gt;_item; __CFAssignWithWriteBarrier((void **)&amp;bucket-&gt;_item, (void *)value); // GC: handles deque/CFStorage cases. if (NULL != cb-&gt;release &amp;&amp; !hasBeenFinalized(array)) &#123; INVOKE_CALLBACK2(cb-&gt;release, allocator, old_value); &#125; array-&gt;_mutations++; END_MUTATION(array); &#125;&#125;//用新的数组代替旧数组部分元素（调用_CFArrayReplaceValues）void CFArrayReplaceValues(CFMutableArrayRef array, CFRange range, const void **newValues, CFIndex newCount) &#123; CF_OBJC_FUNCDISPATCHV(CFArrayGetTypeID(), void, (NSMutableArray *)array, replaceObjectsInRange:NSMakeRange(range.location, range.length) withObjects:(id *)newValues count:(NSUInteger)newCount); __CFGenericValidateType(array, CFArrayGetTypeID()); __CFArrayValidateRange(array, range, __PRETTY_FUNCTION__); CFAssert1(__CFArrayGetType(array) != __kCFArrayImmutable, __kCFLogAssertion, &quot;%s(): array is immutable&quot;, __PRETTY_FUNCTION__); CFAssert2(0 &lt;= newCount, __kCFLogAssertion, &quot;%s(): newCount (%d) cannot be less than zero&quot;, __PRETTY_FUNCTION__, newCount); CHECK_FOR_MUTATION(array); return _CFArrayReplaceValues(array, range, newValues, newCount);&#125; 查：读取可变数组的元素12345678//获取idx位置的数值（调用__CFArrayGetBucketAtIndex）const void *CFArrayGetValueAtIndex(CFArrayRef array, CFIndex idx) &#123; CF_OBJC_FUNCDISPATCHV(CFArrayGetTypeID(), const void *, (NSArray *)array, objectAtIndex:idx); __CFGenericValidateType(array, CFArrayGetTypeID()); CFAssert2(0 &lt;= idx &amp;&amp; idx &lt; __CFArrayGetCount(array), __kCFLogAssertion, &quot;%s(): index (%d) out of bounds&quot;, __PRETTY_FUNCTION__, idx); CHECK_FOR_MUTATION(array); return __CFArrayGetBucketAtIndex(array, idx)-&gt;_item;&#125; 分析可变数组存储方式从“增删改”三个操作里可以看出整个可变数组操作的核心方法就是：_CFArrayReplaceValues 而“查”包括“改”则涉及关于buckets的操作比如：__CFArrayGetBucketAtIndex、__CFArrayGetBucketsPtr 先来看下buckets相关的方法： 1234567891011121314151617181920212223242526272829303132/** 装载元素指针bucket的整块区域都是连续的，因为无论Immutable还是Deque都满足：第idx个指针等于第一个bucket指针+idx，只是可变数组和不可变数组的第一个bucket指针的位置不一样 */#pragma mark bucket/* Only applies to immutable and mutable-deque-using arrays; * Returns the bucket holding the left-most real value in the latter case. *///获取第一个元素Buckets的指针CF_INLINE struct __CFArrayBucket *__CFArrayGetBucketsPtr(CFArrayRef array) &#123; switch (__CFArrayGetType(array)) &#123; //每个数组元素都用一个bucket装着，通过结构体指针来索引，通过指针+1来获取对应bucket装着的元素（item） case __kCFArrayImmutable: //第一个元素的Bucket指针位置：array的指针 + 空数组大小 return (struct __CFArrayBucket *)( (uint8_t *)array + __CFArrayGetSizeOfType(((CFRuntimeBase *)array)-&gt;_cfinfo[CF_INFO_BITS])); case __kCFArrayDeque: &#123; //获取队列结构体的指针 struct __CFArrayDeque *deque = (struct __CFArrayDeque *)array-&gt;_store; //队列结构体的指针 + 队列结构体大小 + 队列左值*bucket大小 return (struct __CFArrayBucket *)((uint8_t *)deque + sizeof(struct __CFArrayDeque) + deque-&gt;_leftIdx * sizeof(struct __CFArrayBucket)); &#125; &#125; return NULL;&#125;/* This shouldn&apos;t be called if the array count is 0. *///获取第idx个元素Buckets的指针CF_INLINE struct __CFArrayBucket *__CFArrayGetBucketAtIndex(CFArrayRef array, CFIndex idx) &#123; switch (__CFArrayGetType(array)) &#123; case __kCFArrayImmutable: case __kCFArrayDeque: return __CFArrayGetBucketsPtr(array) + idx; &#125; return NULL;&#125; 重要的结论：装载元素指针bucket的整块区域都是连续的，因为无论可变还是不可变都满足：第idx个指针等于第一个bucket指针+idx，只是可变数组和不可变数组的第一个bucket指针的位置不一样 有用的信息有： 可变数组数据存储也是连续的 可变数组的元素是存在__CFArrayDeque后面，不可变数组的元素是直接放在__CFArray后面的 可变数组并不是直接将数组跟在__CFArrayDeque后面的，而是偏移了_leftIdx位的 最后一点比较难理解，我们回头看一下__CFArrayDeque这个结构体： 12345struct __CFArrayDeque &#123; uintptr_t _leftIdx; uintptr_t _capacity; /* struct __CFArrayBucket buckets follow here */&#125;; 这里面有两个成员： uintptr_t _capacity：容量 uintptr_t _leftIdx：偏移量 如果说单纯标记数组元素元素的话用_count足够了，完全没必要加_capacity这个成员，加上刚刚的提的偏移了_leftIdx位，我们可以理解这个_capacity是一个大于元素个数的容器，而数组元素只存在容器内的一部分。 而与_capacity相关的主要就一个方法： 1234567891011121314151617enum &#123; __CF_MAX_BUCKETS_PER_DEQUE = LONG_MAX&#125;;/** capacity &lt; 4 =&gt; 返回4 __CF_MAX_BUCKETS_PER_DEQUE &gt; capacity &gt;= 4 =&gt; capacity-&gt;2进制，获取位数n，返回 2^n capacity &gt;= __CF_MAX_BUCKETS_PER_DEQUE =&gt; 返回__CF_MAX_BUCKETS_PER_DEQUE eg： 1~3 =&gt; 4 4~7 =&gt; 8 8~15 =&gt; 16 *///flsl: return the position of the first bit set, or 0 if no bits are set in value.CF_INLINE CFIndex __CFArrayDequeRoundUpCapacity(CFIndex capacity) &#123; if (capacity &lt; 4) return 4; return __CFMin((1 &lt;&lt; flsl(capacity)), __CF_MAX_BUCKETS_PER_DEQUE);&#125; 这个方法主要是根据数组的元素个数来获取这个_capacity大小。 这里主要也是采用二进制来运算的，可能大家看起来有点困难，其实用十进制来描述就十分清楚： 0-9 =&gt; 10 10-99 =&gt;100 100-999 =&gt; 1000 …. 相当于总是用比这个数多一位的数来作为容器的容量。 但同样是为了加快效率，苹果是用二进制来处理的： 0-11 =&gt; 100 即 0-3 =&gt; 4 100-111 =&gt; 1000 即4~7 =&gt; 8 1000-1111 =&gt; 10000 即8~15 =&gt; 16 … 理解了这一点之后，其实只用理解_leftIdx的含义就可以分析出可变数组是怎么存的了，接下来看下_CFArrayReplaceValues。 由于我们重点是了解如何往__CFArrayDeque写数据的，这里我们可以以直接对一个空数组一次性添加4个元素来操作，这时候我们发现__CFArrayDeque是在以下代码下被初始化的： 12345678910111213141516171819202122if (0) &#123;&#125; else if (NULL == array-&gt;_store) &#123; //新数组或者被清空的数组会进来 if (0) &#123; &#125; else if (0 &lt;= futureCnt) &#123; // 声明一个队列对象 struct __CFArrayDeque *deque; // 根据元素总数确定容器可载元素总数 CFIndex capacity = __CFArrayDequeRoundUpCapacity(futureCnt); // 根据容器分配空间大小 CFIndex size = sizeof(struct __CFArrayDeque) + capacity * sizeof(struct __CFArrayBucket); // 初始化deque，加进_store里 deque = (struct __CFArrayDeque *)CFAllocatorAllocate((allocator), size, isStrongMemory(array) ? __kCFAllocatorGCScannedMemory : 0); if (__CFOASafe) __CFSetLastAllocationEventName(deque, &quot;CFArray (store-deque)&quot;); deque-&gt;_leftIdx = (capacity - newCount) / 2;//使得添加了目标元素之后上下剩余的空间是相同的，这时候从头和尾添加少量元素时都不需要重新开辟空间 deque-&gt;_capacity = capacity; __CFAssignWithWriteBarrier((void **)&amp;array-&gt;_store, (void *)deque); if (CF_IS_COLLECTABLE_ALLOCATOR(allocator)) auto_zone_release(objc_collectableZone(), deque); // GC: now safe to unroot the array body. &#125; &#125; else &#123; //...&#125; 注释已经写的很清楚了，默认情况下数组的元素是会放在这个容器的中间的，上下都保留相等的空间。 而作用呢？其实也很明显——就是方便前后元素的增删操作的 小结——可变数组在内存的存储方式至此我们总结一下可变数组的存储方式： __CFArray结构体和不可变数组一样，根据是否有设置自定义CallBack，来判断是否在结构体后面开辟内存来存取CFArrayCallBacks，而真正数组元素是存在通过_store索引的一个__CFArrayDeque结构体后面的一块内存空间的，而且前后还保留了一些空位，以供元素的增删操作 _CFArrayReplaceValues——详细解读可变数组的操作过程直接上源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** * @param array:要操作的数组 * @param range:要操作的范围：range.location表示从原数组的哪位开始操作，range.length表示原数组中需要操作的数量 * @param newValues:操作的新数值数组 * @param newCount:新数值的数量 */// This function does no ObjC dispatch or argument checking;// It should only be called from places where that dispatch and check has already been done, or NSCFArrayvoid _CFArrayReplaceValues(CFMutableArrayRef array, CFRange range, const void **newValues, CFIndex newCount) &#123; CHECK_FOR_MUTATION(array); BEGIN_MUTATION(array); //cb: callback //idx: 循环内的临时变量 //cnt: 数组变化之前的元素个数 //futureCnt: 数组变化之后的元素个数 //newv: 新值数组，纳入Allocator管理 //buffer: 256个指针元素的数组,大小为256X8=2048bit const CFArrayCallBacks *cb; CFIndex idx, cnt, futureCnt; const void **newv, *buffer[256]; cnt = __CFArrayGetCount(array); futureCnt = cnt - range.length + newCount; CFAssert1(newCount &lt;= futureCnt, __kCFLogAssertion, &quot;%s(): internal error 1&quot;, __PRETTY_FUNCTION__); cb = __CFArrayGetCallBacks(array); CFAllocatorRef allocator = __CFGetAllocator(array); //判断是否需要retain /* Retain new values if needed, possibly allocating a temporary buffer for them */ if (NULL != cb-&gt;retain &amp;&amp; !hasBeenFinalized(array)) &#123; //个数小于256，就直接用个数为256的c数组，否则Allocator来管理内存 newv = (newCount &lt;= 256) ? (const void **)buffer : (const void **)CFAllocatorAllocate(kCFAllocatorSystemDefault, newCount * sizeof(void *), 0); // GC OK if (newv != buffer &amp;&amp; __CFOASafe) __CFSetLastAllocationEventName(newv, &quot;CFArray (temp)&quot;); for (idx = 0; idx &lt; newCount; idx++) &#123; ///#define INVOKE_CALLBACK2(P, A, B) (P)(A, B) newv[idx] = (void *)INVOKE_CALLBACK2(cb-&gt;retain, allocator, (void *)newValues[idx]); &#125; &#125; else &#123; newv = newValues; &#125; array-&gt;_mutations++; // 将一个数组的元素区域分成了三个部分，每个部分都可能为空 // A: 从索引下标零的位置到小于 range.location 的区域 // B: 传入的 range.location 区域 // C: 从 range.location + range.length 到数组末尾 //干掉B区域数据 if (0 &lt; range.length) &#123; __CFArrayReleaseValues(array, range, false); &#125; if (0) &#123; &#125; else if (NULL == array-&gt;_store) &#123; //新数组或者被清空的数组会进来 if (0) &#123; &#125; else if (0 &lt;= futureCnt) &#123; // 声明一个队列对象 struct __CFArrayDeque *deque; // 根据元素总数确定容器可载元素总数 CFIndex capacity = __CFArrayDequeRoundUpCapacity(futureCnt); // 根据容器分配空间大小 CFIndex size = sizeof(struct __CFArrayDeque) + capacity * sizeof(struct __CFArrayBucket); // 初始化deque，加进_store里 deque = (struct __CFArrayDeque *)CFAllocatorAllocate((allocator), size, isStrongMemory(array) ? __kCFAllocatorGCScannedMemory : 0); if (__CFOASafe) __CFSetLastAllocationEventName(deque, &quot;CFArray (store-deque)&quot;); deque-&gt;_leftIdx = (capacity - newCount) / 2;//原因：使得添加了目标元素之后上下剩余的空间是相同的，这时候从头和尾添加少量元素时都不需要重新开辟空间 deque-&gt;_capacity = capacity; __CFAssignWithWriteBarrier((void **)&amp;array-&gt;_store, (void *)deque); if (CF_IS_COLLECTABLE_ALLOCATOR(allocator)) auto_zone_release(objc_collectableZone(), deque); // GC: now safe to unroot the array body. &#125; &#125; else &#123; // Deque //deque已经创建出来，元素个数不为空 if (0) &#123; &#125; else if (range.length != newCount) &#123; //根据B区域元素个数，挪动A、C区域 __CFArrayRepositionDequeRegions(array, range, newCount); &#125; &#125; //以上操作只是开辟新空间，实际上并没有把新的元素弄进数组里，下面把元素移进数组里 // copy in new region B elements if (0 &lt; newCount) &#123; if (0) &#123; &#125; else &#123; // Deque struct __CFArrayDeque *deque = (struct __CFArrayDeque *)array-&gt;_store; struct __CFArrayBucket *raw_buckets = (struct __CFArrayBucket *)((uint8_t *)deque + sizeof(struct __CFArrayDeque)); ///TODO：objc_memmove_collectable??? objc_memmove_collectable(raw_buckets + deque-&gt;_leftIdx + range.location, newv, newCount * sizeof(struct __CFArrayBucket)); &#125; &#125; __CFArraySetCount(array, futureCnt); if (newv != buffer &amp;&amp; newv != newValues) CFAllocatorDeallocate(kCFAllocatorSystemDefault, newv); END_MUTATION(array);&#125; 代码量很大，这里简单介绍一下整个Replace的步骤 对newValues进行retain处理 清除原数组中要被替代的range内的元素 根据新增个数对原来内存的元素进行元素挪动（可能还会为新数组开辟空件） 把新增元素添加到对应的deque的位置 其中1、2、4步骤都直接展示出来的，而且也没有什么理解上的困难，我们重点看下第3步，第三步是通过__CFArrayRepositionDequeRegions实现的，这也是理解整个数组元素操作的重要一步： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// may move deque storage, as it may need to grow dequestatic void __CFArrayRepositionDequeRegions(CFMutableArrayRef array, CFRange range, CFIndex newCount) &#123; // newCount elements are going to replace the range, and the result will fit in the deque struct __CFArrayDeque *deque = (struct __CFArrayDeque *)array-&gt;_store; struct __CFArrayBucket *buckets; CFIndex cnt, futureCnt, numNewElems; CFIndex L, A, B, C, R; buckets = (struct __CFArrayBucket *)((uint8_t *)deque + sizeof(struct __CFArrayDeque)); cnt = __CFArrayGetCount(array); futureCnt = cnt - range.length + newCount; L = deque-&gt;_leftIdx; // length of region to left of deque A = range.location; // length of region in deque to left of replaced range B = range.length; // length of replaced range C = cnt - B - A; // length of region in deque to right of replaced range R = deque-&gt;_capacity - cnt - L; // length of region to right of deque numNewElems = newCount - B; // deque-&gt;_capacity一般情况下都是2^n这里是让n-17, CFIndex wiggle = deque-&gt;_capacity &gt;&gt; 17; // so: 二进制位数小于20位或者十进制小于131072，wiggle = 4， 否则 wiggle = 2^(n-17) if (wiggle &lt; 4) wiggle = 4; if (deque-&gt;_capacity &lt; (uint32_t)futureCnt || (cnt &lt; futureCnt &amp;&amp; L + R &lt; wiggle)) &#123; //此时一定要开辟新的空间，大于可抖动范围，不能通过挪动数据完成操作 /** * 开辟新的一整块的连续空间（包括deque结构体），计算新的数据块（A、C）在新空间的位置，memove移植过去， */ // must be inserting or space is tight, reallocate and re-center everything CFIndex capacity = __CFArrayDequeRoundUpCapacity(futureCnt + wiggle); CFIndex size = sizeof(struct __CFArrayDeque) + capacity * sizeof(struct __CFArrayBucket); CFAllocatorRef allocator = __CFGetAllocator(array); Boolean collectableMemory = CF_IS_COLLECTABLE_ALLOCATOR(allocator); struct __CFArrayDeque *newDeque = (struct __CFArrayDeque *)CFAllocatorAllocate(allocator, size, isStrongMemory(array) ? __kCFAllocatorGCScannedMemory : 0); if (__CFOASafe) __CFSetLastAllocationEventName(newDeque, &quot;CFArray (store-deque)&quot;); struct __CFArrayBucket *newBuckets = (struct __CFArrayBucket *)((uint8_t *)newDeque + sizeof(struct __CFArrayDeque)); CFIndex oldL = L; CFIndex newL = (capacity - futureCnt) / 2; CFIndex oldC0 = oldL + A + B; CFIndex newC0 = newL + A + newCount; newDeque-&gt;_leftIdx = newL; newDeque-&gt;_capacity = capacity; if (0 &lt; A) objc_memmove_collectable(newBuckets + newL, buckets + oldL, A * sizeof(struct __CFArrayBucket)); if (0 &lt; C) objc_memmove_collectable(newBuckets + newC0, buckets + oldC0, C * sizeof(struct __CFArrayBucket)); __CFAssignWithWriteBarrier((void **)&amp;array-&gt;_store, (void *)newDeque); if (!collectableMemory &amp;&amp; deque) CFAllocatorDeallocate(allocator, deque); if (CF_IS_COLLECTABLE_ALLOCATOR(allocator)) auto_zone_release(objc_collectableZone(), newDeque); //printf(&quot;3: array %p store is now %p (%lx)\\n&quot;, array, array-&gt;_store, *(unsigned long *)(array-&gt;_store)); return; &#125; /** * numNewElems &lt; 0 说明数据变少了，看是A小还是C小，memmove两者小的那块区域即可 * numNewElems &gt; 0 说明数据变多了，如果A &gt; C 且 C下面的R区域够大就memmove C区域即可， C &lt; A 且上面的L区域够大就memmove A区域即可 * numNewElems &gt; 0 且不符合上述规则， 需要根据具体情况同时移动A、C区域 */ if ((numNewElems &lt; 0 &amp;&amp; C &lt; A) || (numNewElems &lt;= R &amp;&amp; C &lt; A)) &#123; // move C // deleting: C is smaller // inserting: C is smaller and R has room CFIndex oldC0 = L + A + B; CFIndex newC0 = L + A + newCount; if (0 &lt; C) objc_memmove_collectable(buckets + newC0, buckets + oldC0, C * sizeof(struct __CFArrayBucket)); // GrP GC: zero-out newly exposed space on the right, if any if (oldC0 &gt; newC0) memset(buckets + newC0 + C, 0, (oldC0 - newC0) * sizeof(struct __CFArrayBucket)); &#125; else if ((numNewElems &lt; 0) || (numNewElems &lt;= L &amp;&amp; A &lt;= C)) &#123; // move A // deleting: A is smaller or equal (covers remaining delete cases) // inserting: A is smaller and L has room CFIndex oldL = L; CFIndex newL = L - numNewElems; deque-&gt;_leftIdx = newL; if (0 &lt; A) objc_memmove_collectable(buckets + newL, buckets + oldL, A * sizeof(struct __CFArrayBucket)); // GrP GC: zero-out newly exposed space on the left, if any if (newL &gt; oldL) memset(buckets + oldL, 0, (newL - oldL) * sizeof(struct __CFArrayBucket)); &#125; else &#123; // now, must be inserting, and either: // A&lt;=C, but L doesn&apos;t have room (R might have, but don&apos;t care) // C&lt;A, but R doesn&apos;t have room (L might have, but don&apos;t care) // re-center everything CFIndex oldL = L; CFIndex newL = (L + R - numNewElems) / 2; newL = newL - newL / 2; CFIndex oldC0 = oldL + A + B; CFIndex newC0 = newL + A + newCount; deque-&gt;_leftIdx = newL; if (newL &lt; oldL) &#123; if (0 &lt; A) objc_memmove_collectable(buckets + newL, buckets + oldL, A * sizeof(struct __CFArrayBucket)); if (0 &lt; C) objc_memmove_collectable(buckets + newC0, buckets + oldC0, C * sizeof(struct __CFArrayBucket)); // GrP GC: zero-out newly exposed space on the right, if any if (oldC0 &gt; newC0) memset(buckets + newC0 + C, 0, (oldC0 - newC0) * sizeof(struct __CFArrayBucket)); &#125; else &#123; if (0 &lt; C) objc_memmove_collectable(buckets + newC0, buckets + oldC0, C * sizeof(struct __CFArrayBucket)); if (0 &lt; A) objc_memmove_collectable(buckets + newL, buckets + oldL, A * sizeof(struct __CFArrayBucket)); // GrP GC: zero-out newly exposed space on the left, if any if (newL &gt; oldL) memset(buckets + oldL, 0, (newL - oldL) * sizeof(struct __CFArrayBucket)); &#125; &#125; &#125; 可以看出苹果在这块还是有做比较多的优化的，大致讲下的思路： 首先根据是否要创建空间分为两种情况：需要分配新内存、不需要分配新内存 需要分配新内存：重新开辟一整个能容得下新数组的容器。按照之前的规则（把数据放到中间）把对应区域的数据拷到相应的位置中去 不需要分配新内存：判断是增加数据还是减少数据 减少数据：判断是A区域小还是C区域小 A区域小：移动A区域，重置没用的内存空间 C区域小：移动C区域，重置没用的内存空间 增加数据：判断两者区域关系以及上下是否有足够的容量 A比C小，且上面的L区域比增加的个数大：移动A区域，重置没用的内存空间 C比A小，且下面的R区域比增加的个数大：移动C区域，重置没用的内存空间 其他情况：按照之前的规则（把数据放到中间）同时移动A、C区域，清除没用数据 （实现和我分析的可能部分顺序上有不同，但思路相同） 关于L、A、B、C、R区域的划分可以参照下图：顺便举了几个例子： 不需要创建内存空间，只移动A（C）一块区域： 不需要创建内存空间，但是要移动A、C两块区域： 需要创建内存空间，同时移动A、C两块区域","tags":[{"name":"iOS","slug":"iOS","permalink":"http://alfredzhenyu.github.io/tags/iOS/"},{"name":"Objc","slug":"Objc","permalink":"http://alfredzhenyu.github.io/tags/Objc/"},{"name":"源码解析","slug":"源码解析","permalink":"http://alfredzhenyu.github.io/tags/源码解析/"}]},{"title":"2017年的新年寄语","date":"2017-02-07T12:59:48.000Z","path":"2017/02/07/2017年的新年寄语/","text":"​ 这是2017年过完农历新年的第一篇blog，过年给自己放了个小假，休息了一段时间。刚过完年，不想写太多技术性的东西。所谓新年新希望新目标，在这里也想给自己定个新的目标，算是给自己定需求，督促下自己吧。 2017的“小目标” 进一步了解一些iOS的底层实现 CF Objc-runtime 如果有机会的话可以接触下JavaScriptCore、WebKit这类网络框架 了解下iOS8、9、10的一些新特性 深入去学习iOS的动态部署方案 了解下怎么样在iOS上面跑Lua，如果方案可行的话可以考虑深入学习下lua，有机会应用在工程里去 深入理解RN底层的实现原理，争取能做到把之前学的RN应用到项目中去 深入学习OpenGL 游戏开发（从OpenGL入门过渡到3D游戏的开发，学习一个游戏引擎） SpiritKit（有机会可以顺带了解下Metal） Unity3d/unreal还没纠结好选哪个 算法的积累（希望有机会能沉淀下） 了解下视频直播技术，希望有机会能参与其中 总结暂时就这么多啦….其实我觉得已经不是几个”小目标”这么简单了，能完成估计会有另外一个飞跃吧。 共勉！！！","tags":[{"name":"生活","slug":"生活","permalink":"http://alfredzhenyu.github.io/tags/生活/"}]},{"title":"iOS开发黑科技之Xcode多Target开发","date":"2017-01-13T02:39:45.000Z","path":"2017/01/13/iOS开发黑科技之Xcode多Target开发/","text":"前言很多时候会出现一种情况：同一个工程文件需要生成多个相似的app 比如： 同一个app的Pro、Lite、Free版 同一个模板工程应用于不同app 同一个app的iPad、iPhone版 在这种情况下，就需要在一个Xcode工程下添加多个Target来实现，这里我们就来看下，如何在一个工程下进行多Target开发 Target的创建复制一个新Target 点击工程-找到控制窗口的侧边栏里找到TARGETS-右键呼出菜单点击Duplicate 可以看到 我们发现图片箭头地方多了新的Copy Target，但通常这个名字显得有点不太专业，并不满足我们的要求，我们需要对其进行改名 更改Target名字直接双击控制栏里的侧边栏的Target，更改名字如图： 更改Scheme名字点击最上方在更改当前编译的Target位置里点击edit scheme选项，出现如图控制窗 点击Manage Scemes找到需要更改名字的Sceme,双击重命名 更改.plist文件名双击需要更改的plist文件名，输入文件名即可，如图 但发现更改名字后工程无法识别，可以找到对应Target的Build Setting找到一个选项Info.plist File，更改成对应路径即可 多Target开发实际项目中通常会出现不同的Target使用不同的资源、代码 这里，我来讲讲我在这块的一些经验： 不同Target不同资源的处理在资源文件夹中新建一个文件夹TargetDiff用于装不同Target不一样的资源，这里有个小技巧，就是在TargetDiff文件夹下建多个文件夹以对应不同的Target，然后再每个Target文件夹下对于同一种资源取相同的名字，如图： 可以看到不同的Target：Bemewings和Bemetoy下都有Logo.bundle然后下面有login_logo.png等等的同名资源 这时候我们只要在右侧更改其对应的Target Membership，选择不同的Target，这时候不同Target编译的时候，只有在membership之内的资源才会打包进app内，那么就可以实现只写一套加载资源的代码，就可以索引到对应Target的资源，从而应用在不同的Target上 不同Target不同代码的处理Target标识符打开不同Target下的Build Setting，找到下面这一类： 把Enable Foundation Assertions设置为YES 在Preprocessor Macros下的每一个选项都添加一个宏用于标识对应的Target 在这里我添加了一个BEMEWINGS以对应我的Bemewings的Target 这时候可以在AppDelegate里就可以加入以下代码来实现不同Target不同处理： User-Defined标识上面的那种方法只是简单的识别是否是某个Target，但是实际开发中会出现这样的需求： 假设有三四个相似的app（Target）可能其中有一两个使用到这个功能模块，运行了这段代码，而其他则没有，那么就需要用到User-Defined来将代码模块功能化，通过Xcode的选项来控制不同Target、甚至不同编译版本是否开启关闭这个功能: 先上图： 以字段_BM_SHELLSCORE_ENABLE为例 注： 前面加下划线是因为这是个私有变量，其实外界是访问不到这个的 另外这里的值写YES、NO或者任意字符串都是可以的，这只是一个宏，真正值是啥取决于后面的操作： 设置全局宏： 如图： 在对应的添加宏定义 把_BM_SHELLSCORE_ENABLE当值时，可以这样定义 1-D&apos;BM_SHELLSCORE_ENABLE=$(_BM_SHELLSCORE_ENABLE)&apos; 把_BM_SHELLSCORE_ENABLE当字符串时，可以这样定义 1-D&apos;BM_SHELLSCORE_OPEN_INFO=@&quot;$(_BM_SHELLSCORE_ENABLE)&quot;&apos; 注： BM_SHELLSCORE_ENABLE是真真正正能代码中使用的宏 $(_BM_SHELLSCORE_ENABLE)表示取_BM_SHELLSCORE_ENABLE的值 设置局部宏： 点击Target-Build Phases-点击需要宏的文件-添加Compiler Flags，输入上面一样的的宏定义即可 注意： 定义多个宏时，一定要换行，换行的方式是Option+enter键，不能直接enter 功能模块控制： 对于功能模块的代码统一加入宏: 12345#if BM_SHELLSCORE_ENABLE//code here#else//code here#endif 这时候，你就可以通过更改工程文件-Target里Build Setting里的User-Deifined值来控制是否开启这项功能 User-Defined扩展而对于String类型的宏更多用于在不同编译版本下设置不同的URL，因为一般来说测试环境与正式环境访问的地址，域名都不一样，那么就可以通过User-Defined里一个字段下面的Debug、Release设置不同的URL，就可以实现同一段代码访问同一个宏，实际使用的是不同值的情况","tags":[{"name":"iOS","slug":"iOS","permalink":"http://alfredzhenyu.github.io/tags/iOS/"},{"name":"Xcode","slug":"Xcode","permalink":"http://alfredzhenyu.github.io/tags/Xcode/"}]},{"title":"Objc的Runtime源码解读（三）之消息（Messaging）机制","date":"2017-01-11T08:54:46.000Z","path":"2017/01/11/Objc的Runtime源码解读（三）之消息（Messaging）机制/","text":"目录： 消息传递机制 ​ 消息传递(Messaging) I’m sorry that I long ago coined the term “objects” for this topic because it gets many people to focus on the lesser idea. The big idea is “messaging” – that is what the kernal[sic] of Smalltalk is all about… The key in making great and growable systems is much more to design how its modules communicate rather than what their internal properties and behaviors should be.","tags":[{"name":"iOS","slug":"iOS","permalink":"http://alfredzhenyu.github.io/tags/iOS/"},{"name":"Objc","slug":"Objc","permalink":"http://alfredzhenyu.github.io/tags/Objc/"},{"name":"源码解析","slug":"源码解析","permalink":"http://alfredzhenyu.github.io/tags/源码解析/"}]},{"title":"Objc的Runtime源码解读（二）之方法的存储","date":"2017-01-09T08:50:25.000Z","path":"2017/01/09/Objc的Runtime源码解读（二）之方法的存储/","text":"目录： 方法的存储 class_data_bits结构体 class_rw_t和class_ro_t结构体 从realizeClass看方法的存储 相关源码 class_data_bits 结构体正如上篇文章提到的一样，方法储存在obj_class的class_data_bits类型的结构体里 123456struct objc_class : objc_object &#123; isa_t isa; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags&#125;; class_data_bits 结构体： 123struct class_data_bits_t &#123; uintptr_t bits;&#125; 下面我们来看下这里的bits每一位的含义： 注意到在objc_class注释里写的 class_data_bits_t 相当于 class_rw_t 指针加上 rr/alloc 的标志。而在class_data_bits_t的方法中可以看到下面这个方法便捷的返回class_rw_t * 指针 12345// data pointer#define FAST_DATA_MASK 0x00007ffffffffff8ULclass_rw_t* data() &#123; return (class_rw_t *)(bits &amp; FAST_DATA_MASK);&#125; 可以看出 class_rw_t * 指针的地址从第3到第47位 而bits的其他位： 1234#define FAST_IS_SWIFT (1UL&lt;&lt;0)#define FAST_HAS_DEFAULT_RR (1UL&lt;&lt;1)#define FAST_REQUIRES_RAW_ISA (1UL&lt;&lt;2)#define FAST_DATA_MASK 0x00007ffffffffff8UL isSwift()``FAST_IS_SWIFT 用于判断 Swift 类 hasDefaultRR()``FAST_HAS_DEFAULT_RR 当前类或者父类含有默认的 retain/release/autorelease/retainCount/_tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference 方法 requiresRawIsa()``FAST_REQUIRES_RAW_ISA 当前类的实例需要 raw isa 注：通过 objc_class 中的 data() 方法和 class_data_bits_t 中的 data() 方法返回的是同一个class_rw_t *指针 class_rw_t和class_ro_t结构体class_rw_t源码12345678910111213struct class_rw_t &#123; uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols; Class firstSubclass; Class nextSiblingClass;&#125;; 可以看到: 这里面存储着属性(properties)、方法(methods)、遵循的协议(protocols) 同时这内部还有一个指针叫做ro，类型为class_ro_t 我们再来看下class_ro_t的源码 class_ro_t源码12345678910111213141516struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; uint32_t instanceSize; uint32_t reserved; const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties;&#125;; 发现这两个有点像也有属性、方法、协议 从字面上就可以理解这两个的差别： ro：read only。存储的是当前类在编译期间就已经确定的属性(baseProperties)、方法(baseMethodList)以及遵循的协议(baseProtocols) rw：read write。存储的是一些自己实现的方法（包括分类）(methods)、属性(properties)、以及遵循的协议(protocols) 要想深入理解方法的存储可以看下class_ro_t和 class_rw_t在加载ObjC运行时是怎么调用的，可以找到 realizeClass 这个方法 从realizeClass看方法的存储主要看下方法内部class_ro_t和 class_rw_t相关的部分： 12345const class_ro_t *ro = (const class_ro_t *)cls-&gt;data();class_rw_t *rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1);rw-&gt;ro = ro;rw-&gt;flags = RW_REALIZED|RW_REALIZING;cls-&gt;setData(rw); 主要的步骤： 从 class_data_bits_t 调用 data 方法，将结果从 class_rw_t 强制转换为 class_ro_t 指针 初始化一个 class_rw_t 结构体 设置结构体 ro 的值以及 flag 最后设置正确的 data。 从这里可以get到： realizeClass 方法执行前 realizeClass 方法执行后 实际上： 在编译期间类的结构中的 class_data_bits_t *data 指向的是一个 class_ro_t * 指针 在加载运行时代码运行realizeClass 之后，class_data_bits_t *data 才指向 class_rw_t 指针。 但此时方法，属性以及协议列表均为空。这时需要 realizeClass 调用 methodizeClass 方法来将类自己实现的方法（包括分类）、属性和遵循的协议加载到 methods、 properties 和 protocols 列表中 备注： realizeClass主要作用是对类进行第一次初始化包括 分配可读写数据空间（class_rw_t） 返回真正的类结构（Class） 1static Class realizeClass(Class cls) 相关源码 TODO:补充相关代码解析注释 方法结构体12345struct method_t &#123; SEL name;//方法名 const char *types;//在ObjC中叫做类型编码(Type Encoding) IMP imp;//实现的指针&#125;; 属性结构体1234struct property_t &#123; const char *name; const char *attributes;&#125;; 协议结构体1234567891011121314151617struct protocol_t : objc_object &#123; const char *mangledName; struct protocol_list_t *protocols; method_list_t *instanceMethods; method_list_t *classMethods; method_list_t *optionalInstanceMethods; method_list_t *optionalClassMethods; property_list_t *instanceProperties; uint32_t size; // sizeof(protocol_t) uint32_t flags; // Fields below this point are not always present on disk. const char **_extendedMethodTypes; const char *_demangledName; property_list_t *_classProperties; const char *demangledName();&#125;; ​ 参考资料 Draveness的github Classes and Metaclasses Tagged Pointer 类型编码 Type Encodings","tags":[{"name":"iOS","slug":"iOS","permalink":"http://alfredzhenyu.github.io/tags/iOS/"},{"name":"Objc","slug":"Objc","permalink":"http://alfredzhenyu.github.io/tags/Objc/"},{"name":"源码解析","slug":"源码解析","permalink":"http://alfredzhenyu.github.io/tags/源码解析/"}]},{"title":"Objc的Runtime源码解读（一）之isa指针","date":"2017-01-09T02:22:43.000Z","path":"2017/01/09/Objc的Runtime源码解读（一）之isa指针/","text":"目录： isa指针 objc_object和objc_class结构体 isa指针的作用 isa_t结构体 objc_object和objc_class结构体 ObjC都是C语言结构体，所有对象都包含一个类型为isa_t的isa指针 123struct objc_object &#123; isa_t isa;&#125;; 所有继承自NSObject的类的实例化后的对象都会包含一个类型为isa_t的结构体​ 在ObjC的Class定义为一个名为objc_class 的结构体： 123456struct objc_class : objc_object &#123; isa_t isa; Class superclass; cache_t cache; class_data_bits_t bits;&#125;; 可以看出objc_class 结构体是继承自 objc_object 的，所有的类也有一个isa，所以Objc中的类本身也是一个对象 isa指针的作用首先对象的方法（实例方法、类方法）是不存储在对象的结构体中的，不然创建同一个类的不同对象会造成内存的冗余，所以： 当实例方法被调用时，会通过对象的isa来查找对应的类，然后在class_data_bits_t 结构体中查找对应方法的实现，同时使用 super_class 来查找继承的类，进而找到继承的方法 当类方法被调用时，会通过类的isa来查找对应的元类，然后在元类查找对应类方法的实现，以保证通过相同的机制来查找方法的实现 1//TODO:元类和类共用一套实现代码，怎样通过类方法查找类方法的 上图是各个对象的isa的指向图，这里需要注意的是，在64位以后才有的isa_t类型这个结构体，需要通过一定的处理才能得到他需要指向的对象，而在64位以前是isa类型，单纯的指向它需要的对象，下面会讲到。 ​ isa_t结构体 源码定义： x86_64: 12345678910111213141516171819202122232425#define ISA_MASK 0x00007ffffffffff8ULL#define ISA_MAGIC_MASK 0x001f800000000001ULL#define ISA_MAGIC_VALUE 0x001d800000000001ULL#define RC_ONE (1ULL&lt;&lt;56)#define RC_HALF (1ULL&lt;&lt;7)union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits; struct &#123; uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 44; uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 8; &#125;;&#125;; arm64: 123456789101112131415161718192021222324#define ISA_MASK 0x0000000ffffffff8ULL#define ISA_MAGIC_MASK 0x000003f000000001ULL#define ISA_MAGIC_VALUE 0x000001a000000001ULL#define RC_ONE (1ULL&lt;&lt;45)#define RC_HALF (1ULL&lt;&lt;18)union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits; struct &#123; uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 33; uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 19; &#125;;&#125;; （MacOS，虚拟机是x86_64，而iOS是arm64） 可以看出不同的架构上，字段是一样的，只不过位数和实现上有些差别，这里统一用x86的来讲解 isa_t 是一个 union 类型的结构体。其中的 isa_t、cls、 bits 还有结构体共用同一块地址空间。而实际上 isa 总共会占据 64 位的内存空间，可以从bits看出来 下面我们从初始化的过程来看这64位每一位的意义： 1234567891011121314151617inline void objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)&#123; initIsa(cls, true, hasCxxDtor);&#125;inline void objc_object::initIsa(Class cls, bool indexed, bool hasCxxDtor) &#123; if (!indexed) &#123; isa.cls = cls; &#125; else &#123; isa.bits = ISA_MAGIC_VALUE; isa.has_cxx_dtor = hasCxxDtor; isa.shiftcls = (uintptr_t)cls &gt;&gt; 3; &#125;&#125; 对整个 isa 的值 bits 进行设置，传入 ISA_MAGIC_VALUE： 1#define ISA_MAGIC_VALUE 0x001d800000000001ULL 可以看出实际上设置的是indexed以及magic这两个字段 indexed表示isa_t类型： 0在迁移到64位之前的时候使用，这时候的isa是没有struct部分，通过object-&gt;isa得到的是cls的指针（那时不是isa_t类型，而是isa类型） 1在迁移到64位之后的时候使用，这时候的isa增加了struct部分，通过object-&gt;isa得到的是64位的bits值（需要用shiftcls位的偏移来获取cls的指针） magic的值为0x3b用于调试器判断当前对象是真的对象还是没初始化的空间 TODO: magic值具体怎么判断当前对象的 has_cxx_dtor实际上也是64位中的1位，表示当前对象时候有C++、ObjC的析构器 shiftcls就是类指针，因为类指针规定要按照字节（8bit）对齐内存，所以后三位bit为000（可以输出[NSObject class]指针看下），这里为了减小内存消耗，特意右移3位写进shiftcls内，这个字段就相当于64位以前的isa类型指针，遵循上面的指向图 【同时可以打印对象指针，可以发现对象内存地址的后四位都是0，说明ObjC在初始化内存时是以16字节对齐的，分配的内存地址后四位都是0】 注意： 由于改版至64位，不可以通过object-&gt;isa直接获取cls指针，所以新增了ISA()方法来获取 123456#define ISA_MASK 0x00007ffffffffff8ULLinline Class objc_object::ISA() &#123; return (Class)(isa.bits &amp; ISA_MASK);&#125; ​ 其他bits 在 isa_t 中，我们还有一些没有介绍的其它 bits，在这个小结就简单介绍下这些 bits 的作用 has_assoc对象含有或者曾经含有关联引用，没有关联引用的可以更快地释放内存 weakly_referenced对象被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放 deallocating对象正在释放内存 has_sidetable_rc对象的引用计数太大了，存不下 extra_rc对象的引用计数超过 1，会存在这个这个里面，如果引用计数为 10，extra_rc 的值就为 9 参考资料 Draveness的github Objective-C Runtime Programming Guide What is a meta-class in Objective-C? objc_explain_Classes_and_metaclasses Storing things in isa Why do we need C Unions? objc_explain_Non-pointer_isa Tagged Pointer ARM64 and You 64位与Tagged Pointer ​","tags":[{"name":"iOS","slug":"iOS","permalink":"http://alfredzhenyu.github.io/tags/iOS/"},{"name":"Objc","slug":"Objc","permalink":"http://alfredzhenyu.github.io/tags/Objc/"},{"name":"源码解析","slug":"源码解析","permalink":"http://alfredzhenyu.github.io/tags/源码解析/"}]},{"title":"《Web性能权威指南》读书笔记（五）","date":"2017-01-04T02:07:00.000Z","path":"2017/01/04/《Web性能权威指南》读书笔记（五）/","text":"目录： 第三部分 HTTP 第十二章 HTTP 2.x 第十三章 优化应用的交付 第三部分 HTTP第十二章 HTTP 2.x二进制分帧层二进制分层指的是位于套接字接口与应用可见的高层HTTP API之间的一个新机制：HTTP 1.x是以换行符作为纯文本的分隔符，而HTTP2.0则将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码。 流、消息、帧为了理解二进制分层引入一下几个新概念： 流：已建立的连接上的双向字节流。 消息：与逻辑消息对应的完整的一系列数据帧。 帧：HTTP 2.0 通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流。 所有 HTTP 2.0 通信都在一个TCP连接上完成，这个连接可以承载任意数量的双向数据流。相应地，每个数据流（请求、响应）以消息的形式发送，而消息由一或多个帧组成，这些帧可以乱序发送，然后再根据每个帧首部的流标识符重新组装。这样，HTTP 2.0 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。相应地，很多流可以并行地在同一个 TCP 连接上交换消息。 举个例子：图 12-3 中包含了同一个连接上多个传输中的数据流:客户端正在向服务器传输一个 DATA 帧(stream 5)，与此同时，服务器正向客户端乱序发送 stream 1 和 stream 3 的一系列帧。此时，一个连接上有 3 个请求 / 响应并行交换! 这样做的优势： 可以并行交错地发送请求，请求之间互不影响; 可以并行交错地发送响应，响应之间互不干扰; 只使用一个连接即可并行发送多个请求和响应; 消除不必要的延迟，从而减少页面加载的时间; 不必再为绕过 HTTP 1.x 限制而多做很多工作; 请求优先级把 HTTP 消息分解为很多独立的帧的另外一个优势：可以通过优化这些帧的交错和传输顺序，进一步提升性能。HTTP2.0通过往每个流中加入一个31bit的优先级字段 0 表示最高优先级 231-1 表示最低优先级 这样，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。具体来讲，服务器可以根据流的优先级，控制资源分配(CPU、内存、带宽)，而在响应数据准备好之后，优先将最高优先级的帧发送给客户端。 每个来源一个连接新的分帧机制带来的另一个好处就是不用依赖于多个TCP连接或者多域名来实现并行机制，此时所有的HTTP2.0连接都是持久化的，客户端和服务器之间只需要一个连接即可 流量控制HTTP2.0为数据流和连接提供一个简单的流量控制，这个机制实际上和TCP的流量控制是一样的。然而，由于 TCP 流量控制不能对同一条 HTTP 2.0 连接内的多个流实施差异化策略，因此光有TCP的流量控制是不够的。这正是 HTTP 2.0 流量控制机制出台的原因。 HTTP 2.0 标准没有规定任何特定的算法、值，或者什么时候发送 WINDOW_UPDATE 帧。 因此，实现可以选择自己的算法以匹配自己的应用场景，从而求得最佳性能。 TODO：进一步了解HTTP2.0如何实现流量控制的 服务器推送HTTP 2.0 新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。换句话说，除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确地请求。建立 HTTP 2.0 连接后，客户端与服务器交换 SETTINGS 帧，借此可以限定双向并发的流的最大数量。因此，客户端可以限定推送流的数量，或者通过把这个值设置为 0 而完全禁用服务器推送。 首部压缩在HTTP1.x中由于元数据都是以纯文本方式，通常会给每个请求增加500~800字节的负荷，为提高性能，HTTP 2.0会压缩首部元数据：压缩采用的是首部的差异化编码的方式实现的：客户端和服务端共同维护一张“首部表”来跟踪和存储之前的键-值对，在同一连接中始终存在，有客户端、服务器共同渐进地更新，每个新的首部键-值要么追加到当前表的末尾、要么替换当前的值。而对于相同的数据，不再在每次请求和响应中发送，举个例子：第二个请求只需要发送变化了的路径首部(:path)，其他首部没有变化，不用再发送。这样就可以避免传输冗余的首部，从而显著减少每个请求的开销。 HTTP2.0升级升级HTTP 2.0需要使用到HTTP的Upgrade机制，步骤如下： 发起带有 HTTP 2.0 Upgrade 首部的 HTTP 1.1 请求 如果服务器不支持 HTTP 2.0，就立即返回 HTTP 1.1 响应/服务器就会以 HTTP 1.1 格式返回 101 Switching Protocols 响应，然后立即切换到 HTTP 2.0 并使用新的二进制分帧协议返回响应 分帧首部 16 位的长度前缀意味着一帧大约可以携带 64 KB 数据，不包括 8 字节首部。 8 位的帧类型字段决定如何解释帧其余部分的内容。 8 位的标志字段允许不同的帧类型定义特定于帧的消息标志。 1 位的保留字段始终置为 0。 31 位的流标识符唯一标识 HTTP 2.0 的流。 帧类型字段： DATA:用于传输 HTTP 消息体。 HEADERS:用于传输关于流的额外的首部字段。 PRIORITY:用于指定或重新指定引用资源的优先级。 RST_STREAM:用于通知流的非正常终止。 SETTINGS:用于通知两端通信方式的配置数据。 PUSH_PROMISE:用于发出创建流和服务器引用资源的要约。 PING:用于计算往返时间，执行“活性”检查。 GOAWAY:用于通知对端停止在当前连接中创建流。 WINDOW_UPDATE:用于针对个别流或个别连接实现流量控制。 CONTINUATION:用于继续一系列首部块片段。 发起新流HTTP 2.0 协议规定客户端和服务器都可以发起新流：客户端新流：客户端通过发送类型为HEADERS的帧发起新流，新流包含带有新流ID，可选的31位优先值以及HTTP键-值对首部服务端新流：服务端通过发送类型为PUSH_PROMISE帧来发起推送流，这个帧与HEADERS等效，但它没有优先值由于两端都可以发起新流，流计数器需要一定规则:客户端发起的流具有偶数ID，服务器发起的流具有奇数ID。这样，两端的流ID不会冲突，而且各自持有一个简单的计数器，每次发起新流时递增ID即可。 发起应用数据创建新流并发送HTTP首部之后，之后利用DATA帧发送应用数据，一块应用数据可以分为多个DATA帧，最后一帧要翻转帧首部的END_STREAM字段（HTTP2.0标准要求单帧数据不能超过2^14-1(16383)字节） 第十三章 优化应用的交付 减少DNS查找 重用TCP连接 减少HTTP重定向 使用CDN 去掉不必要的请求 客户端缓存资源 传输压缩过的内容 减少不必要的请求开销 并行处理请求和响应 客户端缓存资源HTTP传输下可以使用首部字段来实现缓存： Cache-Control 首部用于指定缓存时间； Last-Modified 和 ETag 首部提供验证机制 注意两者缺一不可：如果没有指定验证：导致每次都在没有更新的情况下重发相同内容如果没有指定缓存时间：导致每次使用资源时都多余地执行验证检查","tags":[{"name":"网络","slug":"网络","permalink":"http://alfredzhenyu.github.io/tags/网络/"},{"name":"HTTP","slug":"HTTP","permalink":"http://alfredzhenyu.github.io/tags/HTTP/"}]},{"title":"《Web性能权威指南》读书笔记（四）","date":"2016-12-26T03:59:41.000Z","path":"2016/12/26/《Web性能权威指南》读书笔记（四）/","text":"目录： 第三部分 HTTP 第九章 HTTP简史 第十章 Web性能要点 第十一章 HTTP 1.x 第三部分 HTTP第九章 HTTP简史HTTP 0.9：只有一行的协议+悄然起步HTTP 1.0：参考性RFC+迅速发展HTTP 1.1：正式纳入RFC+标准化HTTP 2.0：性能改进+优化 第十章 Web性能要点浏览器优化策略 基于文档的优化：熟悉网络协议，了解文档、CSS 和 JavaScript 解析管道，发现和优先安排关键网 络资源，尽早分派请求并取得页面，使其尽快达到可交互的状态。主要方法是优 先获取资源、提前解析等。 *推测性优化：浏览器可以学习用户的导航模式，执行推测性优化，尝试预测用户的下一次操 作。然后，预先解析 DNS、预先连接可能的目标。 浏览器采用的技术： 资源预取和排定优先次序：文档、CSS 和 JavaScript 解析器可以与网络协议层沟通，声明每种资源的优先 级:初始渲染必需的阻塞资源具有最高优先级，而低优先级的请求可能会被临时 保存在队列中。 DNS预解析：对可能的域名进行提前解析，避免将来 HTTP 请求时的 DNS 延迟。预解析可以 通过学习导航历史、用户的鼠标悬停，或其他页面信号来触发。 TCP预连接：DNS 解析之后，浏览器可以根据预测的 HTTP 请求，推测性地打开 TCP 连接。 如果猜对的话，则可以节省一次完整的往返(TCP 握手)时间。 页面预渲染：某些浏览器可以让我们提示下一个可能的目标，从而在隐藏的标签页中预先渲染 整个页面。这样，当用户真的触发导航时，就能立即切换过来。 关于网站建设中的优化建议： 减少DNS查询：每次域名解析都需要一次网络往返，增加请求的延迟，在查询期间会阻塞请求。 *减少HTTP请求：任何请求都不如没有请求更快，因此要去掉页面上没有必要的资源 使用CDN：从地理上把数据放到接近客户端的地方，可以显著减少每次 TCP 连接的网络延 迟，增加吞吐量。 添加Expires首部并配置ETag标签：相关资源应该缓存，以避免重复请求每个页面中相同的资源。Expires 首部可用 于指定缓存时间，在这个时间内可以直接从缓存取得资源，完全避免 HTTP 请 求。ETag 及 Last-Modified 首部提供了一个与缓存相关的机制，相当于最后一次 更新的指纹或时间戳。 Gzip资源：所有文本资源都应该使用 Gzip 压缩，然后再在客户端与服务器间传输。一般来 说，Gzip 可以减少 60%~80% 的文件大小，也是一个相对简单(只要在服务器上 配置一个选项)，但优化效果较好的举措。 *避免HTTP重定向：HTTP 重定向极其耗时，特别是把客户端定向到一个完全不同的域名的情况下， 还会导致额外的 DNS 查询、TCP 连接延迟，等等。 第十一章 HTTP 1.x对于HTTP1.0的优化策略：升级HTTP1.1 HTTP1.1特性： 持久化连接以支持连接重用 分块传输编码以支持流式响应 请求管道+支持并行请求处理 字节服务以支持基于范围的资源请求 改进的缓存机制 持久化连接非持久化连接 持久化连接 持久 HTTP 可以让我们重用已有的连接来完成多次应用请求，但多次请求必须严格满足先进先出(FIFO)的队列顺序:发送请求，等待响应完成，再发送客户端队列中的下一个请求，HTTP管道是一个很小但对上述工作流却非常重要的一次优化。管道可以让我们把FIFO队列从客户端(请求队列)迁移到服务器(响应队列)。 HTTP管道HTTP管道优化 服务器并行处理优化 HTML 和 CSS 请求同时到达，但先处理的是 HTML 请求; 服务器并行处理两个请求，其中处理 HTML 用时 40 ms，处理 CSS 用时 20 ms; CSS 请求先处理完成，但被缓冲起来以等候发送 HTML 响应;* 发送完 HTML 响应后，再发送服务器缓冲中的 CSS 响应。HTTP 1.x只能严格串行地返回响应。特别是，HTTP 1.x 不允许一个连接上的多个响应数据交错到达(多路复用)，因而一个响应必须完全返回后，下一个响应才会开始传输。 这个会造成的问题： 一个慢响应就会阻塞所有后续请求; 并行处理请求时，服务器必须缓冲管道中的响应，从而占用服务器资源，如果有个响应非常大，则很容易形成服务器的受攻击面; 响应失败可能终止 TCP 连接，从页强迫客户端重新发送对所有后续资源的请求，导致重复处理; 由于可能存在中间代理，因此检测管道兼容性，确保可靠性很重要; 如果中间代理不支持管道，那它可能会中断连接，也可能会把所有请求串联起来。 注意：HTTP 管道技术的应用非常有限，虽然其优点毋庸置疑。今天，一些支持管道的浏览器，通常都将其作为一个高级配置选项，但大多数浏览器都会禁用它。（但如果对服务器和刻画段拥有完全控制的权限，还是建议开启，其中iTunes就利用这个特性，实现性能的优化） 多个TCP连接由于不支持多路复用，浏览器采用允许并行建立多个TCP连接的方式来解决。现实中，大多数现代浏览器，包括桌面和移动浏览器，都支持每个主机打开 6 个连接。这个需要的代价： 更多的套接字会占用客户端、服务器以及代理的资源，包括内存缓冲区和 CPU 时钟周期; 并行 TCP 流之间竞争共享的带宽; 由于处理多个套接字，实现复杂性更高;* 即使并行 TCP 流，应用的并行能力也受限制。实践中，CPU 和内存占用并非微不足道，由此会导致客户端和服务器端的资源占用量上升，运维成本提高。类似地，由于客户端实现的复杂性提高，开发成本也会提高。最后，说到应用的并行性，这种方式提供的好处还是非常有限的。这不是一个长期的方案。 域名分区和上面的原理方法一样，通过手工把资源分散到多个子域名上，由于域名不一样，可以突破浏览器的连接限制，实现更高的并行的能力，域名分区使用的越多，并行能力越强这个需要的代价： 一次额外的 DNS 查询 每多一个套接字都会多消耗两端的一些资源 站点必须手工分离这些资源，并分别把它们托管到多个主机上。域名分区是一种合理但又不完美的优化手段。现实当中，真正因同时打开十几个连接而提升性能的站点并不多，如果你最终使用了很多分区，那么你会发现减少资源数量或者将它们合并为更少的请求，反而能带来更大的好处。 连接与拼合最快的请求是不用请求。减少请求次数总是最好的性能优化手段。如果你无论如何也无法减少请求，那么对 HTTP 1.x 而言，可以考虑把多个资源捆绑打包到一块，通过一次网络请求获取: 连接 把多个 JavaScript 或 CSS 文件组合为一个文件。* 拼合 把多张图片组合为一个更大的复合的图片。优势： 减少协议开销：通过把文件组合成一个资源，可以消除与文件相关的协议开销。* 应用层管道：这两种技术的效果都好像是启用了 HTTP 管道:多个响应的数据前后相继地连接在一起，消除了额外的网络延迟。实际上，就是把管道提高了一层，置入了应用中。问题： 把所有资源都组合到一个文件经常会导致处理和加载不必要的字节。虽然可 以把它看成一种预获取，但代价则是降低了初始启动的速度。 假如打包资源变动频率过高，或是资源包过大的情况下，会得不偿失。 内存占用：即便实际上 只显示了其中的一小块，也要始终把整个图片都保存在内存中 嵌入资源嵌入资源是另一种非常流行的优化方法，把资源嵌入文档可以减少请求的次数。比如，JavaScript 和 CSS 代码，通过适当的 script 和 style 块可以直接放在页面中，而图片甚至音频或 PDF 文件，都可以通过数据URI的方式嵌入到页面中（实际上，常见的一个经验规则是只考虑嵌入 1~2 KB 以下的资源，因为小于这个标准的资源经常会导致比它自身更高的 HTTP 开销。然而，如果嵌入的资源频繁变更， 又会导致宿主文档的无效缓存率升高）","tags":[{"name":"网络","slug":"网络","permalink":"http://alfredzhenyu.github.io/tags/网络/"},{"name":"HTTP","slug":"HTTP","permalink":"http://alfredzhenyu.github.io/tags/HTTP/"}]},{"title":"《Web性能权威指南》读书笔记（三）","date":"2016-12-26T02:51:14.000Z","path":"2016/12/26/《Web性能权威指南》读书笔记（三）/","text":"目录： 第一部分 网络技术概览 第四章 传输层安全（TLS） 第四章 传输层安全个人的理解：HTTPS = TLS + HTTPso：理解TLS，在理解HTTPS中极为重要 TLS与SSLSSL（Secure Sockets Layer，安全套接字）最初是为了保证网上交易安全而开发的一套安全协议，协议通过加密保护客户个人资料，通过认证和完整性检查来确保交易安全，SSL不会影响上层协议，但能保证上层协议的网络通信安全（HTTP、电子邮件、即时通讯）TLS（Transport Layer Security， 传输层安全）：后来被IETF标准化SSL之后改了名字，实际上两者指的是同一个东西，只是在不同时间段，指代不同的协议版本【TLS设计的初衷是在可靠的传输协议（TCP）之上运行的，可是有实现把它放在数据包协议（如UDP）上，形成DTLS（Datagram Transport Layer Security，数据报传输层安全，RFC 6437）旨在以TLS协议为基础，同时兼顾数据包交付模式并提供类似的安全保障】 基本服务TLS目标是在它之上的应用提供三个基本服务： 加密 混淆数据的机制 身份验证 验证身份标识有效性的机制 完整性 检测消息是否被篡改或伪造的机制 具体实现：密钥协商：TLS握手时会采用公钥密码系统（非对称密钥加密）的方式，让通信双方不必事先“认识”，即可商定共享的安全密钥身份验证：TLS时允许通信双方互相验明正身，可以通过相互提供认证证书来验证对方是否是它想联系的服务消息分帧：使用MAC算法（Message Authentication Code，消息认证码）签署每一条消息。MAC算法是一个单向加密的散列函数(本质上是一个校验和)，密钥由连接双方协商确定。只要发送TLS记录，就会生成一个MAC值并附加到该消息中。接收端通过计算和验证这个MAC值来判断消息的完整性和可靠性。 TLS握手• 0 ms:TLS 在可靠的传输层(TCP)之上运行，这意味着首先必须完成 TCP 的“三次握手”，即一次完整的往返。• 56 ms:TCP 连接建立之后，客户端再以纯文本形式发送一些规格说明，比如它所运行的 TLS 协议的版本、它所支持的加密套件列表，以及它支持或希望使用的另外一 些 TLS 选项。• 84 ms:然后，服务器取得 TLS 协议版本以备将来通信使用，从客户端提供的加密套件列表中选择一个，再附上自己的证书【这里应该还有服务器给客户端的公钥，用于非对称加密】，将响应发送回客户端。作为可选项，服务器也可以发送一个请求，要求客户端提供证书以及其他 TLS 扩展参数。• 112 ms:假设两端经过协商确定了共同的版本和加密套件，客户端也高高兴兴地把自己的证书提供给了服务器。然后，客户端会生成一个新的对称密钥，用服务器的公钥来加密，加密后发送给服务器，告诉服务器可以开始加密通信了。 到目前为止，除了用服务器公钥加密的新对称密钥之外，所有数据都以明文形式发送。• 140 ms:最后，服务器解密出客户端发来的对称密钥，通过验证消息的 MAC 检测消息完整性，再返回给客户端一个加密的“Finished”消息。• 168 ms:客户端用它之前生成的对称密钥解密这条消息，验证 MAC，如果一切顺利，则建立信道并开始发送应用数据。 加密 非对称加密：只在建立TLS信道的会话中使用 对称加密：建立TLS之后会一直使用 主要原因是顾及性能问题 以最常用的RSA、AES加密方式为例子：在安装了OpenSSL的话使用以下命令查看12$&gt; openssl speed rsa$&gt; openssl speed aes 可以看出AES需要3s左右完成一次加/解密可以看出RSA需要10s左右完成一次加/解密 TODO：后续可能会针对加解密这块写些文章，毕竟客户端在于服务端交互的时候加解密是必不可少的 应用层协议协商（ALPN）网络上通信可以使用自定义的协议进行通信 HTTP的话可以使用Upgrade机制 + 80端口来协商自定义协议 HTTPS的话由于使用了TLS，除了可以使用HTTP的Upgrade机制来协商，还可以使用ALPN+443端口，在TLS握手时就把协商确定协议 ALPN：在客户端发送ClientHello的过程中增加一个新的字段ProtocolNameList，告诉服务端自己支持的应用协议；服务器检查ProtocolNameList字段，如果支持：在ServerHello消息中以 ProtocolName字段返回选中的协议；如果不支持：断开连接【Upgrade机制会增加一次往返的延迟：会在HTTP部分进行讲解】 服务器名称指示（SNI）网络上可以建立TCP连接的任意两端都可以建立加密TLS信道，客户端只需知道 另一端的IP地址即可建立连接并进行TLS握手。然而，如果服务器想在一个IP地址为多个站点提供服务，而每个站点都拥有自己的TLS证书，那怎么办？就要用到SNI：SNI：该扩展被引入TLS协议，该扩展允许客户端在握手之初就指明要连接的主机名。Web服务器可以检查SNI主机名，选择适当的证书，继续完成握手 TLS会话恢复TLS握手会带来额外的延迟和计算量，造成一定的性能损失。为了挽回某些损失，TLS提供了恢复功能，即在多个连接间共享协商后的安全密钥。 会话标识符（Session Identifier）会话标识符（RFC 5246，在SSL 2.0引入）：服务器支持创建32字节的会话标识符，用于保存一个会话ID和协商后的会话参数。第一次握手时：服务器把ID信息作为“ServerHello”消息的一部分发送出去，自己把其他会话信息存储起来，客户端收到后保存会话ID信息需要恢复时：将该ID包含在会话的“ClientHello”消息中， 告诉服务器自己还记着上次握手协商后的加密套件和密钥呢，从而实现重用。问题：对于每天几百万连接的服务器来说，TLS连接会占用不必要的内存，于是引入会话记录单（Session Ticket） 会话记录单（Session Ticket）会话记录单（RFC 5077）：该机制不用服务器保存每个客户端的会话状态，而是将只有服务器知道的安全密钥加密过的所有会话数据交由客户端保存。第一次握手时：客户端表明其支持会话记录单，则服务器可以在完整TLS握手的最后一次交换中添加一条“新会话记录单”(New Session Ticket)记录，保存对应的会话数据交给客户端，客户端将这个会话记录单保存起来需要恢复时：在 ClientHello 消息中将加密过的会话记录单放在SessionTicket扩展中，服务器拿到之后拿自己的秘钥解密实现重用（这种回复称之为无状态恢复） 会话记录单 和 会话标识符 的区别在于是服务器还是客户端存这个会话记录 TLS记录协议所有经过采用TLS的协议的请求都必须经过记录协议，添加相应的字段，进行一定的数据处理之后才交由TCP发送出去发送端步骤如下： 记录协议接收上层应用数据 接收到的应用数据被切分为块:最大为每条记录214字节，即16KB。 压缩应用数据(可选)。 添加 MAC(Message Authentication Code)或 HMAC。 用商定的加密套件加密数据 交由TCP层传输接收端顺序相反：6 —&gt; 1注意：TLS记录协议最大为16KB。事实上可以自主选择记录大小，小记录会因为分帧而招致较大开销每条记录包含5字节的首部、MAC(在 SSL 3.0、TLS 1.0、TLS 1.1 中最多 20 字节，在 TLS 1.2 中最多 32 字节)，如果使用块加密则还有填充必须接收到整条记录（不是帧）才开始解密和验证。 优化建议 最大限制提升TCP性能 开启会话缓存：在支持的客户端中使用会话记录单，而在不支持的客户端中使用会话标识符 调整TLS记录大小：记录过小会造成分帧浪费，大记录会导致延迟。最好的做法：每个TCP分组恰好封装一个TLS记录，而TLS记录大小恰好占满TCP分配的MSS(Maximum Segment Size，最大段大小)（一方面不要让TLS记录分成多个TCP分组，另一方面又要尽量在一条记录中多发送数据，参考数据如下： IPv4 帧需要 20 字节，IPv6 需要 40 字节; TCP 帧需要 20 字节; TCP 选项需要 40 字节(时间戳、SACK 等)。假设常见的MTU为1500字节，则TLS记录大小在IPv4下是1420字节，在IPv6下是1400字节。为确保向前兼容，建议使用IPv6下的大小:1400字节。当然，如果MTU更小，这个值也要相应调小） 【但应用层无法控制TLS记录大小，一般是服务器编译时的常量或标志，可以通过服务器文档来查看这个值】 禁用服务器的TLS压缩功能 传输级的 TLS 压缩不关心内容，可能会再次压缩已经压缩过的数据(图像、视频， 等等)。双重压缩会浪费服务器和客户端的CPU时间，而且暴露的安全漏洞也很严重，因此 请禁用TLS压缩 确保证书链不会超过拥塞窗口的大小，从信任链中去掉不必要的证书，减少链条层次，或者直接减小证书大小 如果证书链长度超过了 TCP 的初始拥塞窗口(图 4-11)，那我们无意 间就会让握手多了一次往返:证书长度超过拥塞窗口，从而导致服务器停下来等待 客户端的 ACK 消息 启用服务器的OCSP封套功能（证书方面的优化） 启用服务器对SNI的支持 追加HTTP严格传输安全首部（不太理解） （后面这两个，要想进一步了解看书吧，感觉书也没讲特别细，个人也没特别深的理解，就略过了）","tags":[{"name":"网络","slug":"网络","permalink":"http://alfredzhenyu.github.io/tags/网络/"},{"name":"HTTPS","slug":"HTTPS","permalink":"http://alfredzhenyu.github.io/tags/HTTPS/"},{"name":"SSL/TLS","slug":"SSL-TLS","permalink":"http://alfredzhenyu.github.io/tags/SSL-TLS/"}]},{"title":"《Web性能权威指南》读书笔记（二）","date":"2016-12-23T09:03:47.000Z","path":"2016/12/23/《Web性能权威指南》读书笔记（二）/","text":"目录 第一部分 网络技术概览 第三章 UDP构成 ​ 第三章 UDP构成前言 关于UDP的应用，最广为人知同时也是所有浏览器和因特网应用都赖以运作的，就是DNS(Domain Name System，域名系统) HTTP 并未规定要使用 TCP，但现实中所有 HTTP 实现(以及 构建于其上的所有服务)都使用 TCP。不过，这都是过去的事了。IETF 和 W3C 工作组共同制定了一套新 API—— WebRTC(Web Real-Time Communication，Web 实时通信) 无协议服务为什么称之为无协议： 不保证消息交付 不确认，不重传，无超时。 不保证交付顺序 不设置包序号，不重排，不会发生队首阻塞。 不跟踪连接状态 不必建立连接或重启状态机。* 不需要拥塞控制 不内置客户端或网络反馈机制。网络地址转换器为了解决IPv4地址耗尽的问题，提供了临时性方案 —— IP网络地址转换器（NAT）IP网络地址转换器：NAT设备维护一个表，表维护了一张本地IP到外网IP的映射表，这样IP就可以实现不同网络中的映射，从而达到映射，用于解决网络不够用的问题NAT穿透 NAT设备带来的问题： 内部客户端不知道外网 IP 地址，只知道内网 IP 地址。NAT 负责重写每个 UDP 分组中的源端口、地址，以及 IP 分组中的源 IP 地址。 如果客户端在应用数据中以其内网 IP 地址与外网主机通信，连接必然失败 任何到达 NAT 设备外网 IP 的分组还必须有一个目标端口，而且 NAT 转换表中也要有一个条目可以将其转换为内部主机的 IP 地址和端口号。如果没有这个条目(通常是从外网传数据进来)，那到达的分组就会被删除。此时的 NAT 设备就像一个分组过滤器，除非用户通过端口 转发(映射)或类似机制配置过，否则它无法确定将分组发送给哪台内部主机 STUN(Session Traversal Utilities for NAT) STUN协议(RFC 5389)：可以让应用程序发现网络中的地址转换器，发现之后进一步取得为当前连接分配的外网 IP 地址和端口(图 3-5)。为此，这个协议需要一个已知的第三方 STUN 服务器支持，该服务器必须架设在公网上。 应用程序首先向STUN服务器发送一个绑定请求，然后STUN会返回一个响应包含客户端在外网的IP地址+端口 so： 应用程序可以获得外网 IP 和端口，并利用这些信息与对端通信; 发送到 STUN 服务器的出站绑定请求将在通信要经过的 NAT 中建立路由条目， 使得到达该 IP 和端口的入站分组可以找到内网中的应用程序; STUN 协议定义了一个简单 keep-alive 探测机制，可以保证 NAT 路由条目不超时。 两台主机端需要通过 UDP 通信时，它们首先都会向各自的 STUN 服务器发送绑定请求，然后分别使用响应中的外网 IP 地址和端口号交换数据。【但在实际应用中，STUN 并不能适应所有类型的 NAT 和网络配置。不仅如此，某些 情况下 UDP 还会被防火墙或其他网络设备完全屏蔽所以要考虑使用TURN】 TURN(Traversal Using Relays around NAT) TURN(Traversal Using Relays around NAT)协议(RFC 5766)：TURN 中的关键词当然是中继(relay)。这个协议依赖于外网中继设备(图 3-6)在 两端间传递数据 两端都要向同一台 TURN 服务器发送分配请求来建立连接，然后再进行权限协商。协商完毕，两端都把数据发送到 TURN 服务器，再由 TURN 服务器转发，从而实现通信 so： 这样已经不再是端对端的数据较交换 运维TURN服务器的投入很大 中继设备容量必须足够大 实际应用中，最好在其他直连手段都失败的情况下，再使用 TURN。 ICE(Interactive Connectivity Establishment) ICE(Interactive Connectivity Establishment)协议(RFC 5245)：致力在通信各端之间建立一条最有效的通道(图 3-7):能直连就直连，必要时 STUN 协商，再不行使用 TURN UDP优化建议 应用程序必须容忍各种因特网路径条件; 应用程序应该控制传输速度; 应用程序应该对所有流量进行拥塞控制; 应用程序应该使用与 TCP 相近的带宽; 应用程序应该准备基于丢包的重发计数器; 应用程序应该不发送大于路径 MTU 的数据报; 应用程序应该处理数据报丢失、重复和重排; 应用程序应该足够稳定以支持 2 分钟以上的交付延迟; 应用程序应该支持 IPv4 UDP 校验和，必须支持 IPv6 校验和; 应用程序可以在需要时使用 keep-alive(最小间隔 15 秒)。 我很高兴告诉大家:WebRTC 就是符合这些要求的框架!（后面有机会，可以研究下，再写文章）","tags":[{"name":"网络","slug":"网络","permalink":"http://alfredzhenyu.github.io/tags/网络/"},{"name":"TCP","slug":"TCP","permalink":"http://alfredzhenyu.github.io/tags/TCP/"}]},{"title":"《Web性能权威指南》读书笔记(一)","date":"2016-12-23T05:03:13.000Z","path":"2016/12/23/《Web性能权威指南》读书笔记（一）/","text":"目录： 第一部分 网络技术概览 第一章 延迟与带宽 第二章 TCP的构成 第一部分 网络技术概览第一章 延迟与带宽 对网络通信通信部分起决定性因素的有两方面： 延迟：分组从信息源到达目的地所需的时间 带宽：逻辑或物理通信最大吞吐量 延迟的构成 传播延迟：消息从发送端到接收端需要的时间，是信号传播距离和速度的函数 传输延迟：把消息中的所有比特转移到链路中需要的时间，是消息长度和链路速率的函数 处理延迟：处理分组首部、检查位错误及确定分组目标所需的时间 排队延迟：到来的分组排队等待处理的时间客户端到服务器的总延迟时间为以上延迟时间的总和 大多数网站性能的瓶颈都是延迟，而不是带宽 目标：高带宽+低延迟 延迟对用户体验的影响: 第二章 TCP的构成前言因特网两个核心协议： TCP： Transmission Control Protocol ——— RFC 791 IP： Internet Protocol ——— RFC 793【HTTP标准并未规定TCP就是唯一的传输协议，也可以通过UDP或者其他协议来发送HTTP消息】 握手三次握手：三次握手的细节就不讲了，这里主要想说的是其带来的延迟，使得每创建一个新 TCP 连接都要付出很大代价。而提高TCP性能的关键，在于想办法重用连接：TCP 快速打开（TCP Fast Open TFO）：由于非常短的 TCP 连接在 互联网上随处可见，握手阶段已经成为影响网络总延迟的一个重要因素。为解决 这个问题，人们正在积极寻找各种方案，其中 TFO(TCP Fast Open，TCP 快速打 开)就是这样一种机制 Linux 3.7 及之后的内核已经在客户端和服务器中支持 TFO，因此成为了客户端和 服务器操作系统选型的有力候选方案。即便如此，TFO 并不能解决所有问题。 它虽然有助于减少三次握手的往返时间，但却只能在某些情况下有效 TODO:TFO怎么实现握手优化的…拥塞预防及控制： 流量控制 拥塞控制 拥塞预防机制 流量控制： 接收窗口（rwnd）：每一方都要通告自己的接收窗口（rwnd），其中包含能够保存数据的缓冲区大小信息。每次发送的数据都不会大于这个窗口值。如果其中一端（一般为接收端）的缓冲区跟不上数据传输，那它会向发送端通告一个较小的窗口，来减少每次分组发送的数据。 假如窗口为零，则意味着必须由应用层先清空缓冲区，才能再接收剩余数据 窗口缩放(RFC 1323)：最初的TCP规范分配给通告窗口大小的字段是 16位的,最大值(65535字节)。结果在这个限制内经常无法获得最优性能，为解决这个问题，RFC 1323提供了“TCP 窗口缩放”(TCP Window Scaling)选项， 可以把接收窗口大小由 65 535 字节提高到 1G 字节，缩放 TCP 窗口是在三次握手期 间完成的，其中有一个值表示在将来的 ACK 中左移 16 位窗口字段的位数。 现在 TCP 窗口缩放机制在所有主要平台上都是默认启用的。不过，中间节点和 路由器可以重写，甚至完全去掉这个选项。如果你的服务器或客户端的连接不能 完全利用现有带宽，那往往该先查一查窗口大小。在 Linux 中，可以通过如下命 令检查和启用窗口缩放选项: 12$&gt; sysctl net.ipv4.tcp_window_scaling$&gt; sysctl -w net.ipv4.tcp_window_scaling=1 拥塞窗口 拥塞窗口（cwnd）：发送端会初始化一个拥塞窗口（cwnd），但不会通告给对方。每次发送的数据都是cwnd和rwnd的最小值。 慢启动：每次建立完连接之后，采用逐步增大拥塞窗口大小的方式慢慢启动，最初cwnd为一个TCP段，之后采用的是”指数增长“的方式，直到达到拥塞预防机制生效为止【因为很多HTTP连接都是短暂突发的连接，常常会出现还没到达到最大阈值就被终止的情况，因为慢启动会限制可用的吞吐量，而这对于小文件传输非常不利。】 现在目前大多数服务器中常见的初始拥塞窗口为：4段（RFC 2581规定），为减少慢启动的时间，可以尝试把初始拥塞窗口大小增加到10段（RFC 9828规定） 慢启动重启（Slow-Start Restart SSR）：这种机制会在连接空闲一定时间后重置连接的拥塞窗口。道理很简单， 在连接空闲的同时，网络状况也可能发生了变化，为了避免拥塞，理应将拥塞窗 口重置回“安全的”默认值。 SSR 对于那些会出现突发空闲的长周期 TCP 连接(比如 HTTP 的 keep-alive 连接)有很大的影响。因此，我们建议在服务器上禁用 SSR。在 Linux 平台，可以通过如下命令来检查和禁用 SSR: 12$&gt; sysctl net.ipv4.tcp_slow_start_after_idle$&gt; sysctl -w net.ipv4.tcp_slow_start_after_idle=0 拥塞预防机制 拥塞阈值(ssthresh)窗口：慢启动以保守的窗口初始化连接，随后的 每次往返都会成倍提高传输的数据量，直到超过接收端的流量控制窗口，即系统 配置的拥塞阈值(ssthresh)窗口，或者有分组丢失为止，此时拥塞预防算法介入 &emsp; AIMD(Multiplicative Decrease and Additive Increase，倍减加增) 算法：即发生丢包时，先将拥塞窗口减半，然后每次往返再缓慢地给窗口增加一 个固定的值。不过，很多时候 AIMD 算法太过保守，因此又有了新的算法。 &emsp; PRR(Proportional Rate Reduction，比例降速)算法：就是 RFC 6937 规定的一个新算法， 其目标就是改进丢包后的恢复速度。改进效果如何呢?根据谷歌的测量，实现新 算法后，因丢包造成的平均连接延迟减少了 3%~10%。 TODO:PRR如何改进丢包的恢复速度的… 其他 带宽延迟积（Bandwidth-delay product，BDP）：任意时刻处于在发送途中还未收到ACK状态的最大数据量 = 数据链路的容量（带宽） * 端到端的延迟 队首(HOL，Head of Line)阻塞：每个TCP分组都会带着一个唯一的序列号被发，而再对于应用层而言，所有分组必须是按顺序传送到接收端。如果TCP在接收中中途有一个分组没能到达接收端的传输层，那么后续分组必须保存在接收端的 TCP 缓冲区，等待丢失的分组重发并到达接收端，之后再一起提交到应用层，而应用层在接收端只能感受到这种整体的延迟。这种效应称为 TCP 的队首阻塞 抖动：由于队首阻塞造成的延迟分组造成相应的重排和重组，造成分组到达延迟无法预知。这个延迟时间的变化通常被称为抖动，也是影响应用程序性能的一个主要因素【无需按序交付数据或能够处理分组丢失的应用程序，以及对延迟或抖动要求很高的应用程序，最好选择 UDP 等协议。比如语音和游戏状态通信：&emsp; 音频编解码器：就算有个包丢了，只要在音频中插入一个小小的间歇，就可以继续 处理后来的包。只要间歇够小，用户就注意不到，而等待丢失的包则可能导致音 频输出产生无法预料的暂停。相对来说，后者的用户体验更糟糕。&emsp; 3D 游戏中角色更新状态也一样:收到 T 时刻的包而等待 T-1 时刻的 包通常毫无必要。理想情况下，应该可以接收所有状态更新，但为避免游戏延迟， 间歇性的丢包也是可以接受的。】 TCP优化建议： 服务器优化： 更新置最新的内核 增大TCP初始拥塞窗口 禁用慢启动重启 启用窗口缩放 打开TCP快速打开 应用程序调优 重用已经建立的 TCP 连接 减少下载不必要的资源 通过压缩算法把要发送的比特数降到最低 在不同的地区部署服务 器(比如，使用 CDN)，把数据放到接近客户端的地方","tags":[{"name":"网络","slug":"网络","permalink":"http://alfredzhenyu.github.io/tags/网络/"},{"name":"TCP","slug":"TCP","permalink":"http://alfredzhenyu.github.io/tags/TCP/"}]},{"title":"资源目录整理","date":"2016-12-22T06:22:40.000Z","path":"2016/12/22/资源目录整理/","text":"平时每天都会打开几十个网站没时间一一消化，就一直晾着越积越多，收藏夹也太多，一般塞进去就不会翻出来看，所以管理起来也是麻烦…本篇就会把之前自己涉及的领域使用到的有用的学习网站汇总起来，分享给大家，也方便自己的学习管理： 协议、网络相关学习网站 协议分析、网络安全 ​ ​ 优秀博客OpenGL相关学习网站 通俗语言解释OpenGL中着色器，渲染管线，光栅化 ​ 优秀博客iOS学习网站 Apple Open Source Core Foundation API 优秀博客 RunLoop解析(YYKit作者的blog) iOS开源代码解析 NSArray、NSDictionary底层实现 Glow技术博客","tags":[{"name":"总结","slug":"总结","permalink":"http://alfredzhenyu.github.io/tags/总结/"}]},{"title":"第一篇博客","date":"2016-12-21T06:44:34.000Z","path":"2016/12/21/第一篇博客/","text":"之前就一直想抽空搞下自己的技术博客，但是一直忙这忙那的，没时间搞，但开blog，无论对找工作也好，提升自己的能力，丰富自己的生活也罢，感觉对自己都有好处。而且最近受到各种刺激，把自己的技术沉淀下去的这种期望越来越强，于是把时间腾开把想搞已久的blog开起来…也希望自己以后能多多抽时间把自己了解到的技术，都归纳总结起来吧（虽然感觉项目一忙起来，这些都是空话…） 想用之前同事说的一句话作为结尾，总结最近的生活： 生活除了眼前的苟且… 还有远方的苟且…","tags":[{"name":"生活","slug":"生活","permalink":"http://alfredzhenyu.github.io/tags/生活/"}]}]